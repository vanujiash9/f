<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr·∫Øc Nghi·ªám Deep Learning Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4A90E2; /* Xanh d∆∞∆°ng ch·ªß ƒë·∫°o */
            --primary-dark: #357ABD;
            --secondary-color: #50E3C2; /* Xanh ng·ªçc cho accent */
            --background-light: #f7f9fc;
            --background-dark: #2c3e50; /* Dark mode background */
            --text-light: #f5f6fa; /* S√°ng h∆°n cho dark mode */
            --text-dark: #333333;
            --text-dark-secondary: #555555;
            --card-background-light: #ffffff;
            --card-background-dark: #34495e; /* Dark mode card */
            --border-color-light: #e0e0e0;
            --border-color-dark: #4a627a;
            --correct-color: #2ecc71; /* Xanh l√° cho ƒë√°p √°n ƒë√∫ng */
            --incorrect-color: #e74c3c; /* ƒê·ªè cho ƒë√°p √°n sai */
            --font-family: 'Montserrat', sans-serif;
            --box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            --border-radius: 8px;
            --text-on-secondary-dark: #253342; /* M√†u ch·ªØ t·ªëi tr√™n n·ªÅn secondary ·ªü dark mode */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            line-height: 1.6;
            background-color: var(--background-light);
            color: var(--text-dark);
            display: flex;
            transition: background-color 0.3s, color 0.3s;
        }

        .app-wrapper {
            display: flex;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        /* --- Thanh ƒëi·ªÅu h∆∞·ªõng c√¢u h·ªèi (Sidebar) --- */
        .question-sidebar {
            width: 280px;
            background-color: var(--card-background-light);
            border-right: 1px solid var(--border-color-light);
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
            transition: background-color 0.3s, border-color 0.3s, left 0.3s ease-in-out;
            position: fixed;
            left: -280px;
            top: 0;
            height: 100%;
            z-index: 1000;
        }
        .question-sidebar.open {
            left: 0;
        }


        .sidebar-header {
            margin-bottom: 20px;
            text-align: center;
        }
        .sidebar-header h2 {
            font-size: 1.5em;
            color: var(--primary-color);
            margin-bottom: 5px;
        }
        .sidebar-progress {
            font-size: 0.9em;
            color: var(--text-dark-secondary);
        }

        .sidebar-list {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 10px;
        }
        .sidebar-list::-webkit-scrollbar {
            width: 6px;
        }
        .sidebar-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: var(--border-radius);
        }
        .sidebar-list::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: var(--border-radius);
        }
        .sidebar-list::-webkit-scrollbar-thumb:hover {
            background: #aaa;
        }


        .question-nav-item {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            margin-bottom: 8px;
            border-radius: var(--border-radius);
            border: 1px solid transparent;
            border-left: 4px solid transparent; /* Default border */
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s, color 0.2s;
            font-weight: 500;
        }
        .question-nav-item:hover:not(.current) {
            background-color: #e9eff5;
        }
        .question-nav-item.current {
            background-color: var(--primary-color);
            color: var(--text-light);
            font-weight: 600;
            border-left-color: var(--primary-dark);
        }
        .question-nav-item.answered-correct {
            border-left-color: var(--correct-color);
            background-color: #e8f5e9; /* Light green */
        }
        .question-nav-item.answered-incorrect {
            border-left-color: var(--incorrect-color);
            background-color: #ffebee; /* Light red */
        }
        /* Ensure current overrides answered styles for background/text color */
        .question-nav-item.answered-correct.current,
        .question-nav-item.answered-incorrect.current {
            background-color: var(--primary-color);
            color: var(--text-light);
            border-left-color: var(--primary-dark); /* Or keep specific color if needed */
        }


        .nav-item-number {
            margin-right: 10px;
            font-weight: 600;
            min-width: 20px;
            text-align: right;
        }
        .nav-item-flag {
            margin-left: auto;
            font-size: 0.8em;
        }
        .nav-item-flag.flagged {
            color: var(--incorrect-color);
        }

        .sidebar-footer {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .btn-icon {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: var(--text-dark-secondary);
            transition: color 0.2s;
        }
        .btn-icon:hover {
            color: var(--primary-color);
        }
        .btn-sidebar-action {
            padding: 8px 15px;
            background-color: var(--primary-color);
            color: var(--text-light);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        .btn-sidebar-action:hover {
            background-color: var(--primary-dark);
        }

        #openSidebarBtn {
            position: fixed;
            left: 15px;
            top: 15px;
            z-index: 1001;
            display: block;
            padding: 10px 12px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.2em;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            cursor: pointer;
        }
         @media (min-width: 901px) {
            #openSidebarBtn {
                display: none;
            }
            .question-sidebar {
                position: relative;
                left: 0;
            }
        }


        /* --- N·ªôi dung Quiz ch√≠nh --- */
        .quiz-main-content {
            flex-grow: 1;
            padding: 30px;
            overflow-y: auto;
            background-color: var(--background-light);
            transition: margin-left 0.3s ease-in-out;
        }

        .quiz-header {
            text-align: center;
            margin-bottom: 30px;
        }
        .quiz-header h1 {
            font-size: 1.8em;
            color: var(--text-dark);
            margin-bottom: 15px;
        }
        .progress-bar-container {
            height: 12px;
            background-color: #e0e0e0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        .progress-bar-fill {
            height: 100%;
            width: 0%;
            background-color: var(--secondary-color);
            border-radius: var(--border-radius);
            transition: width 0.4s ease-in-out;
        }

        .quiz-area {
            background-color: var(--card-background-light);
            padding: 30px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            max-width: 700px;
            margin: 0 auto;
        }

        .quiz-card-top-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px dashed var(--border-color-light);
        }
        .timer-display { /* S·∫Ω ·∫©n ƒëi b·∫±ng JS */
            font-size: 1.1em;
            font-weight: 600;
            color: var(--primary-color);
        }
        .timer-icon {
            margin-right: 5px;
        }
        .difficulty-display {
            font-size: 0.9em;
            color: var(--text-dark-secondary);
            background-color: #f0f0f0;
            padding: 5px 10px;
            border-radius: var(--border-radius);
        }

        .question-content h2 {
            font-size: 1.4em;
            margin-bottom: 25px;
            color: var(--text-dark);
            line-height: 1.5;
        }

        .options-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 25px;
        }

        .option {
            background-color: #f9f9f9;
            border: 2px solid var(--border-color-light);
            padding: 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-weight: 500;
            text-align: left;
            width: 100%;
        }
        .option:hover:not(.disabled) {
            border-color: var(--primary-color);
            background-color: #e9f3ff;
        }

        .option.disabled {
            cursor: not-allowed;
            background-color: #f0f0f0;
            border-color: #e0e0e0;
            color: #aaa;
            opacity: 0.7;
        }

        .option.correct {
            border-color: var(--correct-color) !important;
            background-color: var(--correct-color) !important;
            color: var(--text-light) !important;
            opacity: 1 !important;
        }
        .option.incorrect {
            border-color: var(--incorrect-color) !important;
            background-color: var(--incorrect-color) !important;
            color: var(--text-light) !important;
            opacity: 1 !important;
        }

        .explanation-container {
            background-color: #e9f3ff;
            border: 1px solid #d2e3fc;
            border-radius: var(--border-radius);
            padding: 20px;
            margin-top: 25px;
            color: #3a506b;
        }
        .explanation-container h3 {
            color: var(--primary-dark);
            margin-bottom: 10px;
        }
        .explanation-container p {
            line-height: 1.7;
        }
        .feedback-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px dashed #d2e3fc;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .feedback-section span {
            font-size: 0.9em;
            color: var(--text-dark-secondary);
        }
        .feedback-btn {
            padding: 6px 12px;
            border-radius: var(--border-radius);
            border: none;
            cursor: pointer;
            font-size: 0.85em;
            transition: opacity 0.2s;
        }
        .feedback-btn:hover {
            opacity: 0.8;
        }
        .feedback-btn[data-feedback="positive"] { background-color: var(--correct-color); color: white;}
        .feedback-btn[data-feedback="negative"] { background-color: var(--incorrect-color); color: white;}


        .quiz-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color-light);
        }
        .btn {
            padding: 12px 25px;
            border-radius: var(--border-radius);
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 1em;
            transition: background-color 0.2s, transform 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn:active:not(:disabled) {
            transform: translateY(1px);
        }
        .btn.btn-secondary {
            background-color: #e0e0e0;
            color: var(--text-dark-secondary);
        }
        .btn.btn-secondary:hover:not(:disabled) {
            background-color: #d0d0d0;
        }
        .btn.btn-primary {
            background-color: var(--primary-color);
            color: var(--text-light);
        }
        .btn.btn-primary:hover:not(:disabled) {
            background-color: var(--primary-dark);
        }
        .btn.btn-action {
            background-color: #f0f0f0;
            color: var(--text-dark-secondary);
            border: 1px solid var(--border-color-light);
        }
        .btn.btn-action:hover:not(:disabled) {
            background-color: #e0e0e0;
        }
        .btn.btn-action .flag-icon.flagged {
            color: var(--incorrect-color);
        }
         .btn.btn-action .flag-icon:not(.flagged) {
            color: var(--text-dark-secondary);
        }
        .btn:disabled {
            background-color: #f0f0f0 !important;
            color: #aaa !important;
            cursor: not-allowed;
        }


        /* --- Khu v·ª±c k·∫øt qu·∫£ --- */
        .result-area {
            text-align: center;
            padding: 40px;
            background-color: var(--card-background-light);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            max-width: 600px;
            margin: 50px auto;
        }
        .result-summary h2 {
            font-size: 2em;
            color: var(--primary-color);
            margin-bottom: 20px;
        }
        .final-score-display {
            font-size: 1.5em;
            font-weight: 600;
            margin-bottom: 15px;
        }
        .result-area p {
            font-size: 1.1em;
            color: var(--text-dark-secondary);
            margin-bottom: 30px;
        }

        .result-actions .btn {
            padding: 15px 30px;
            font-size: 1.1em;
        }
        .flagged-questions-review {
            margin-top: 30px;
            text-align: left;
        }
        .flagged-questions-review h3 {
            margin-bottom: 10px;
            color: var(--primary-dark);
        }
        #flaggedList {
            list-style: none;
            padding: 0;
            max-height: 200px;
            overflow-y: auto;
        }
        #flaggedList li {
            padding: 8px 5px;
            border-bottom: 1px dashed var(--border-color-light);
            cursor: pointer;
            color: var(--primary-color);
            transition: color 0.2s, background-color 0.2s;
            border-radius: 4px;
            margin-bottom: 3px;
        }
        #flaggedList li:hover {
            color: var(--primary-dark);
            background-color: #e9eff5;
        }
        #flaggedList li:last-child {
            border-bottom: none;
        }

        /* Dark Mode Specifics */
        body.dark-mode {
            background-color: var(--background-dark);
            color: var(--text-light);
        }
        body.dark-mode .question-sidebar {
            background-color: var(--card-background-dark);
            border-right-color: var(--border-color-dark);
        }
        body.dark-mode .sidebar-header h2 { color: var(--secondary-color); }
        body.dark-mode .sidebar-progress,
        body.dark-mode .btn-icon,
        body.dark-mode .difficulty-display { color: #bdc3c7; }
        body.dark-mode .difficulty-display { background-color: #2c3e50;}

        body.dark-mode .question-nav-item { color: var(--text-light); border-left-color: transparent;}
        body.dark-mode .question-nav-item:hover:not(.current) { background-color: #3e5771; }
        body.dark-mode .question-nav-item.current {
            background-color: var(--secondary-color);
            color: var(--text-on-secondary-dark);
            border-left-color: #45B8A0; /* Darker shade of secondary for border */
        }
        body.dark-mode .question-nav-item.answered-correct {
            border-left-color: var(--correct-color);
            background-color: #304034; /* Dark green */
        }
        body.dark-mode .question-nav-item.answered-incorrect {
            border-left-color: var(--incorrect-color);
            background-color: #4a3234; /* Dark red */
        }
        body.dark-mode .question-nav-item.answered-correct.current,
        body.dark-mode .question-nav-item.answered-incorrect.current {
            background-color: var(--secondary-color);
            color: var(--text-on-secondary-dark);
            border-left-color: #45B8A0;
        }

        body.dark-mode .sidebar-list::-webkit-scrollbar-track { background: #2c3e50; }
        body.dark-mode .sidebar-list::-webkit-scrollbar-thumb { background: #555; }
        body.dark-mode .sidebar-list::-webkit-scrollbar-thumb:hover { background: #777; }


        body.dark-mode .sidebar-footer { border-top-color: var(--border-color-dark); }
        body.dark-mode .btn-sidebar-action {
            background-color: var(--secondary-color);
            color: var(--text-on-secondary-dark);
        }
        body.dark-mode .btn-sidebar-action:hover { background-color: #45B8A0; } /* Darker secondary */


        body.dark-mode .quiz-main-content { background-color: var(--background-dark); }
        body.dark-mode .quiz-header h1 { color: var(--text-light); }
        body.dark-mode .progress-bar-container { background-color: #3e5771; }
        body.dark-mode .progress-bar-fill { background-color: var(--primary-color); }

        body.dark-mode .quiz-area, body.dark-mode .result-area {
            background-color: var(--card-background-dark);
            border: 1px solid var(--border-color-dark);
        }
        body.dark-mode .quiz-card-top-info { border-bottom-color: var(--border-color-dark); }
        body.dark-mode .timer-display { color: var(--secondary-color); }

        body.dark-mode .question-content h2 { color: var(--text-light); }

        body.dark-mode .option {
            background-color: #3e5771;
            border-color: var(--border-color-dark);
            color: var(--text-light);
        }
        body.dark-mode .option:hover:not(.disabled) {
            border-color: var(--secondary-color);
            background-color: #4a627a;
        }

        body.dark-mode .option.disabled {
            background-color: #2c3e50 !important;
            opacity: 0.5;
            border-color: #3e5771 !important;
            color: #788ca0 !important;
        }
        /* .correct and .incorrect already have !important */

        body.dark-mode .explanation-container {
            background-color: #293a4a;
            border-color: #3e5771;
            color: #bdc3c7;
        }
        body.dark-mode .explanation-container h3 { color: var(--secondary-color); }
        body.dark-mode .feedback-section { border-top-color: #3e5771; }
        body.dark-mode .feedback-section span { color: #bdc3c7; }

        body.dark-mode .quiz-controls { border-top-color: var(--border-color-dark); }
        body.dark-mode .btn.btn-secondary {
            background-color: #3e5771;
            color: #bdc3c7;
        }
        body.dark-mode .btn.btn-secondary:hover:not(:disabled) { background-color: #4a627a; }
        body.dark-mode .btn.btn-primary {
            background-color: var(--secondary-color);
            color: var(--text-on-secondary-dark);
        }
        body.dark-mode .btn.btn-primary:hover:not(:disabled) { background-color: #45B8A0; } /* Darker secondary */
        body.dark-mode .btn.btn-action {
            background-color: #3e5771;
            color: #bdc3c7;
            border-color: var(--border-color-dark);
        }
        body.dark-mode .btn.btn-action:hover:not(:disabled) { background-color: #4a627a; }
        body.dark-mode .btn:disabled {
            background-color: #2c3e50 !important;
            color: #566573 !important;
        }
        body.dark-mode .result-summary h2 { color: var(--secondary-color); }
        body.dark-mode .flagged-questions-review h3 { color: var(--secondary-color); }
        body.dark-mode #flaggedList li {
            border-bottom-color: var(--border-color-dark);
            color: var(--secondary-color);
        }
        body.dark-mode #flaggedList li:hover { color: #A3E4D7; background-color: #3e5771;}

        @media (max-width: 600px) {
            .app-wrapper { flex-direction: column; }
            .question-sidebar {
                width: 100%;
                height: 50vh;
                left: 0;
                top: -100vh;
                border-right: none;
                border-bottom: 1px solid var(--border-color-light);
                box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            }
            .question-sidebar.open {
                top: 0;
            }
            #openSidebarBtn {
                 top: 10px; left: 10px;
            }

            .quiz-main-content { padding: 15px; }
            .quiz-area { padding: 20px; }
            .quiz-card-top-info { flex-direction: column; gap: 10px; align-items: flex-start;}
            .question-content h2 { font-size: 1.2em; }
            .option { padding: 12px; }
            .quiz-controls { flex-direction: column; gap: 10px; }
            .quiz-controls .btn { width: 100%; }
            .result-actions { flex-direction: column; gap: 10px; }
            .result-actions .btn { width: 100%; }
        }
        #toast-notification {
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 12px 25px;
            border-radius: var(--border-radius);
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, bottom 0.3s ease-in-out;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-weight: 500;
        }
        #toast-notification.show {
            bottom: 30px;
            opacity: 1;
        }

    </style>
</head>
<body>
    <div class="app-wrapper">
        <nav class="question-sidebar" id="questionSidebar">
            <div class="sidebar-header">
                <h2>C√¢u h·ªèi</h2>
                <div class="sidebar-progress">
                    <span id="answeredCountDisplay">0</span>/<span id="totalSidebarQuestionsDisplay">0</span>
                </div>
            </div>
            <div class="sidebar-list" id="questionNavList">
            </div>
            <div class="sidebar-footer">
                <button id="toggleDarkModeBtn" class="btn-icon" title="Ch·∫ø ƒë·ªô S√°ng/T·ªëi">üåì</button>
                 <button id="saveProgressBtnSidebar" class="btn-sidebar-action" title="L∆∞u ti·∫øn ƒë·ªô hi·ªán t·∫°i">L∆∞u B√†i</button>
                <button id="restartQuizBtnSidebar" class="btn-sidebar-action" title="L√†m l·∫°i b√†i t·ª´ ƒë·∫ßu">L√†m L·∫°i</button>
            </div>
        </nav>

        <button id="openSidebarBtn" title="M·ªü danh s√°ch c√¢u h·ªèi">‚ò∞</button>

        <main class="quiz-main-content" id="quizMainContent">
            <header class="quiz-header">
                <h1>Tr·∫Øc Nghi·ªám Deep Learning Chuy√™n S√¢u</h1>
                <div class="progress-bar-container">
                    <div class="progress-bar-fill" id="mainProgressBar"></div>
                </div>
            </header>

            <section class="quiz-area" id="quizAreaEl">
                <div class="quiz-card-top-info">
                    <div class="timer-display" id="timerDisplay" style="display: none;">
                        <span class="timer-icon">‚è±Ô∏è</span> Th·ªùi gian: <span id="timeLeftDisplay"></span>
                    </div>
                    <div class="difficulty-display" id="difficultyDisplayEl">ƒê·ªô kh√≥: Medium</div>
                </div>

                <div class="question-content">
                    <h2 id="questionTextEl">C√¢u h·ªèi s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y...</h2>
                </div>

                <div class="options-container" id="optionsContainerEl">
                </div>

                <div class="explanation-container" id="explanationContainerEl" style="display: none;">
                    <h3>Gi·∫£i th√≠ch chi ti·∫øt:</h3>
                    <p id="explanationTextEl"></p>
                    <div class="feedback-section">
                        <span>N·ªôi dung n√†y c√≥ h·ªØu √≠ch?</span>
                        <button class="feedback-btn" data-feedback="positive">üëç C√≥</button>
                        <button class="feedback-btn" data-feedback="negative">üëé Kh√¥ng</button>
                    </div>
                </div>

                <div class="quiz-controls">
                    <button class="btn btn-secondary" id="prevQuestionBtnEl" disabled> < L√πi</button>
                    <button class="btn btn-action" id="flagQuestionBtnEl">
                        <span class="flag-icon" id="flagIconControlEl">üè≥Ô∏è</span><span id="flagBtnTextEl">ƒê√°nh d·∫•u</span>
                    </button>
                    <button class="btn btn-primary" id="nextQuestionBtnEl">Ti·∫øp ></button>
                </div>
            </section>

            <section class="result-area" id="resultAreaEl" style="display: none;">
                <div class="result-summary">
                    <h2>Ch√∫c m·ª´ng b·∫°n ƒë√£ ho√†n th√†nh!</h2>
                    <div class="final-score-display">
                        ƒêi·ªÉm s·ªë: <span id="finalScoreDisplay">0</span>/<span id="totalResultQuestionsDisplay">0</span> (<span id="finalPercentageDisplay">0</span>%)
                    </div>
                    <p id="resultMessageEl">H√£y c·ªë g·∫Øng h∆°n ·ªü l·∫ßn sau nh√©!</p>
                    <div class="result-actions">
                        <button class="btn btn-primary" id="restartQuizBtnResultEl">L√†m L·∫°i T·ª´ ƒê·∫ßu</button>
                        <button class="btn btn-secondary" id="reviewAnswersBtnEl">Xem L·∫°i B√†i L√†m</button>
                    </div>
                </div>
                 <div class="flagged-questions-review" id="flaggedQuestionsReviewAreaEl" style="display:none;">
                    <h3>C√¢u h·ªèi ƒë√£ ƒë√°nh d·∫•u c·∫ßn xem l·∫°i:</h3>
                    <ul id="flaggedListEl"></ul>
                </div>
            </section>
        </main>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script>
        // ===================================================================================
        // == B·∫†N H√ÉY D√ÅN M·∫¢NG 60 C√ÇU H·ªéI ƒê·∫¶Y ƒê·ª¶ C·ª¶A M√åNH V√ÄO ƒê√ÇY THAY CHO M·∫¢NG M·∫™U N√ÄY ==
        // ===================================================================================
        const questions = [
    // --- EASY (10 c√¢u) ---
    {
        question: "GAN l√† vi·∫øt t·∫Øt c·ªßa c·ª•m t·ª´ n√†o?",
        options: ["A) General Adversarial Networks", "B) Generative Adversarial Networks", "C) Gradient Ascent Networks", "D) Generated Autoencoder Networks"],
        correct: 1,
        explanation: "GAN l√† vi·∫øt t·∫Øt c·ªßa Generative Adversarial Networks, m·ªôt l·ªõp c√°c m√¥ h√¨nh h·ªçc m√°y ƒë∆∞·ª£c gi·ªõi thi·ªáu b·ªüi Ian Goodfellow v√† c·ªông s·ª± v√†o nƒÉm 2014.",
        difficulty: "Easy"
    },
    {
        question: "Trong ki·∫øn tr√∫c GAN c∆° b·∫£n, c√≥ bao nhi√™u m·∫°ng n∆°-ron ch√≠nh?",
        options: ["A) M·ªôt", "B) Hai", "C) Ba", "D) B·ªën"],
        correct: 1,
        explanation: "GAN c∆° b·∫£n bao g·ªìm hai m·∫°ng n∆°-ron ch√≠nh: Generator (b·ªô sinh) v√† Discriminator (b·ªô ph√¢n bi·ªát), ch√∫ng 'c·∫°nh tranh' v·ªõi nhau trong qu√° tr√¨nh hu·∫•n luy·ªán.",
        difficulty: "Easy"
    },
    {
        question: "M·ª•c ti√™u c·ªßa Generator trong GAN l√† g√¨?",
        options: ["A) Ph√¢n bi·ªát d·ªØ li·ªáu th·∫≠t v√† gi·∫£", "B) T·∫°o ra d·ªØ li·ªáu gi·∫£ tr√¥ng gi·ªëng h·ªát d·ªØ li·ªáu th·∫≠t", "C) T√≠nh to√°n h√†m m·∫•t m√°t", "D) T·ªëi ∆∞u h√≥a Discriminator"],
        correct: 1,
        explanation: "Generator c·ªë g·∫Øng h·ªçc c√°ch t·∫°o ra c√°c m·∫´u d·ªØ li·ªáu m·ªõi (gi·∫£) sao cho ch√∫ng kh√¥ng th·ªÉ ph√¢n bi·ªát ƒë∆∞·ª£c v·ªõi c√°c m·∫´u d·ªØ li·ªáu th·∫≠t b·ªüi Discriminator.",
        difficulty: "Easy"
    },
    {
        question: "YOLO l√† vi·∫øt t·∫Øt c·ªßa c·ª•m t·ª´ n√†o trong lƒ©nh v·ª±c ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng?",
        options: ["A) You Only Learn Once", "B) You Only Look Once", "C) Your Object Learning Observer", "D) Yielding Optimal Location Outputs"],
        correct: 1,
        explanation: "YOLO l√† vi·∫øt t·∫Øt c·ªßa You Only Look Once, m·ªôt thu·∫≠t to√°n ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng n·ªïi ti·∫øng v·ªÅ t·ªëc ƒë·ªô v√† hi·ªáu qu·∫£.",
        difficulty: "Easy"
    },
    {
        question: "ƒê·∫∑c ƒëi·ªÉm n·ªïi b·∫≠t c·ªßa YOLO so v·ªõi c√°c b·ªô ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng hai giai ƒëo·∫°n (two-stage detectors) l√† g√¨?",
        options: ["A) ƒê·ªô ch√≠nh x√°c lu√¥n cao h∆°n", "B) T·ªëc ƒë·ªô ph√°t hi·ªán nhanh h∆°n v√¨ x·ª≠ l√Ω ·∫£nh trong m·ªôt l∆∞·ª£t duy nh·∫•t", "C) Y√™u c·∫ßu √≠t d·ªØ li·ªáu hu·∫•n luy·ªán h∆°n", "D) Ch·ªâ ph√°t hi·ªán ƒë∆∞·ª£c m·ªôt ƒë·ªëi t∆∞·ª£ng trong ·∫£nh"],
        correct: 1,
        explanation: "YOLO l√† m·ªôt b·ªô ph√°t hi·ªán m·ªôt giai ƒëo·∫°n (one-stage), n√≥ th·ª±c hi·ªán d·ª± ƒëo√°n bounding box v√† l·ªõp tr·ª±c ti·∫øp t·ª´ to√†n b·ªô ·∫£nh trong m·ªôt l·∫ßn truy·ªÅn, gi√∫p ƒë·∫°t t·ªëc ƒë·ªô r·∫•t nhanh.",
        difficulty: "Easy"
    },
    {
        question: "Bounding box trong ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng th∆∞·ªùng ƒë∆∞·ª£c bi·ªÉu di·ªÖn b·∫±ng th√¥ng tin g√¨?",
        options: ["A) Ch·ªâ t√™n l·ªõp c·ªßa ƒë·ªëi t∆∞·ª£ng", "B) T·ªça ƒë·ªô t√¢m, chi·ªÅu r·ªông, chi·ªÅu cao (ho·∫∑c t·ªça ƒë·ªô g√≥c tr√™n tr√°i v√† d∆∞·ªõi ph·∫£i)", "C) M·ªôt vector ƒë·∫∑c tr∆∞ng c·ªßa ƒë·ªëi t∆∞·ª£ng", "D) ƒê·ªô s√¢u c·ªßa ƒë·ªëi t∆∞·ª£ng trong ·∫£nh 3D"],
        correct: 1,
        explanation: "M·ªôt bounding box x√°c ƒë·ªãnh v·ªã tr√≠ v√† k√≠ch th∆∞·ªõc c·ªßa ƒë·ªëi t∆∞·ª£ng, th∆∞·ªùng ƒë∆∞·ª£c bi·ªÉu di·ªÖn b·∫±ng t·ªça ƒë·ªô (x, y) c·ªßa t√¢m, chi·ªÅu r·ªông (w), chi·ªÅu cao (h), ho·∫∑c t·ªça ƒë·ªô (xmin, ymin, xmax, ymax) c·ªßa hai g√≥c ƒë·ªëi di·ªán.",
        difficulty: "Easy"
    },
    {
        question: "Trong GAN, n·∫øu Discriminator tr·ªü n√™n qu√° 'gi·ªèi' qu√° s·ªõm, ƒëi·ªÅu g√¨ c√≥ th·ªÉ x·∫£y ra?",
        options: ["A) Generator s·∫Ω h·ªçc nhanh h∆°n", "B) Qu√° tr√¨nh hu·∫•n luy·ªán s·∫Ω ·ªïn ƒë·ªãnh h∆°n", "C) Generator c√≥ th·ªÉ kh√¥ng h·ªçc ƒë∆∞·ª£c g√¨ (vanishing gradients)", "D) GAN s·∫Ω t·∫°o ra ·∫£nh ch·∫•t l∆∞·ª£ng si√™u cao ngay l·∫≠p t·ª©c"],
        correct: 2,
        explanation: "N·∫øu Discriminator qu√° gi·ªèi v√† d·ªÖ d√†ng ph√¢n bi·ªát th·∫≠t/gi·∫£, gradient truy·ªÅn v·ªÅ Generator s·∫Ω r·∫•t nh·ªè ho·∫∑c b·∫±ng kh√¥ng, khi·∫øn Generator kh√¥ng nh·∫≠n ƒë∆∞·ª£c t√≠n hi·ªáu ƒë·ªÉ c·∫£i thi·ªán (vanishing gradients).",
        difficulty: "Easy"
    },
    {
        question: "Anchor boxes trong YOLO ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ l√†m g√¨?",
        options: ["A) ƒê·ªÉ tƒÉng c∆∞·ªùng ƒë·ªô s√°ng c·ªßa ·∫£nh", "B) L√†m c√°c h·ªôp tham chi·∫øu (prior boxes) v·ªõi c√°c t·ª∑ l·ªá v√† k√≠ch th∆∞·ªõc kh√°c nhau ƒë·ªÉ d·ª± ƒëo√°n bounding box t·ªët h∆°n", "C) ƒê·ªÉ l∆∞u tr·ªØ c√°c ƒë·ªëi t∆∞·ª£ng ƒë√£ ph√°t hi·ªán", "D) ƒê·ªÉ chu·∫©n h√≥a k√≠ch th∆∞·ªõc ·∫£nh ƒë·∫ßu v√†o"],
        correct: 1,
        explanation: "Anchor boxes l√† c√°c h·ªôp ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a tr∆∞·ªõc v·ªõi c√°c h√¨nh d·∫°ng v√† k√≠ch th∆∞·ªõc kh√°c nhau. YOLO d·ª± ƒëo√°n ƒë·ªô l·ªách so v·ªõi c√°c anchor box n√†y thay v√¨ d·ª± ƒëo√°n tr·ª±c ti·∫øp t·ªça ƒë·ªô bounding box t·ª´ ƒë·∫ßu.",
        difficulty: "Easy"
    },
     {
        question: "H√†m m·∫•t m√°t (loss function) n√†o KH√îNG ph·ªï bi·∫øn trong hu·∫•n luy·ªán GAN?",
        options: ["A) Binary Cross-Entropy", "B) Wasserstein Loss", "C) Mean Squared Error (MSE)", "D) Minimax Loss"],
        correct: 2,
        explanation: "MSE th∆∞·ªùng d√πng cho c√°c b√†i to√°n h·ªìi quy. GAN th∆∞·ªùng d√πng c√°c bi·∫øn th·ªÉ c·ªßa Cross-Entropy (trong Minimax loss c·ªßa GAN g·ªëc) ho·∫∑c Wasserstein Loss (trong WGAN) ƒë·ªÉ ƒëo s·ª± kh√°c bi·ªát gi·ªØa ph√¢n ph·ªëi d·ªØ li·ªáu th·∫≠t v√† gi·∫£.",
        difficulty: "Easy"
    },
    {
        question: "Th√†nh ph·∫ßn n√†o trong YOLO ch·ªãu tr√°ch nhi·ªám ch√≠nh cho vi·ªác tr√≠ch xu·∫•t c√°c ƒë·∫∑c tr∆∞ng t·ª´ ·∫£nh ƒë·∫ßu v√†o?",
        options: ["A) Head", "B) Neck", "C) Backbone", "D) Non-Maximum Suppression"],
        correct: 2,
        explanation: "Backbone th∆∞·ªùng l√† m·ªôt m·∫°ng CNN m·∫°nh (v√≠ d·ª•: DarkNet, ResNet) c√≥ nhi·ªám v·ª• h·ªçc v√† tr√≠ch xu·∫•t c√°c ƒë·∫∑c tr∆∞ng h√¨nh ·∫£nh t·ª´ c·∫•p th·∫•p ƒë·∫øn c·∫•p cao.",
        difficulty: "Easy"
    },

    // --- MEDIUM (20 c√¢u) ---
    {
        question: "Trong ki·∫øn tr√∫c GAN, Discriminator th∆∞·ªùng ƒë∆∞·ª£c hu·∫•n luy·ªán ƒë·ªÉ t·ªëi ƒëa h√≥a ƒëi·ªÅu g√¨?",
        options: ["A) Kh·∫£ nƒÉng t·∫°o ra d·ªØ li·ªáu gi·∫£", "B) Sai s·ªë khi ph√¢n lo·∫°i d·ªØ li·ªáu th·∫≠t l√† th·∫≠t", "C) Kh·∫£ nƒÉng ph√¢n bi·ªát ch√≠nh x√°c gi·ªØa d·ªØ li·ªáu th·∫≠t v√† d·ªØ li·ªáu gi·∫£", "D) S·ª± t∆∞∆°ng ƒë·ªìng gi·ªØa d·ªØ li·ªáu th·∫≠t v√† d·ªØ li·ªáu gi·∫£"],
        correct: 2,
        explanation: "Discriminator ƒë∆∞·ª£c hu·∫•n luy·ªán ƒë·ªÉ ph√¢n lo·∫°i ch√≠nh x√°c: g√°n nh√£n 'th·∫≠t' cho d·ªØ li·ªáu th·∫≠t v√† 'gi·∫£' cho d·ªØ li·ªáu do Generator t·∫°o ra. N√≥ c·ªë g·∫Øng t·ªëi ƒëa h√≥a ƒë·ªô ch√≠nh x√°c ph√¢n lo·∫°i n√†y.",
        difficulty: "Medium"
    },
    {
        question: "Hi·ªán t∆∞·ª£ng 'mode collapse' trong GAN l√† g√¨?",
        options: ["A) Generator t·∫°o ra nhi·ªÅu lo·∫°i d·ªØ li·ªáu kh√°c nhau nh∆∞ng ch·∫•t l∆∞·ª£ng th·∫•p", "B) Discriminator kh√¥ng th·ªÉ ph√¢n bi·ªát ƒë∆∞·ª£c th·∫≠t gi·∫£", "C) Generator ch·ªâ t·∫°o ra m·ªôt s·ªë √≠t c√°c m·∫´u l·∫∑p ƒëi l·∫∑p l·∫°i, thi·∫øu s·ª± ƒëa d·∫°ng", "D) C·∫£ Generator v√† Discriminator ƒë·ªÅu ng·ª´ng h·ªçc"],
        correct: 2,
        explanation: "Mode collapse x·∫£y ra khi Generator ch·ªâ h·ªçc ƒë∆∞·ª£c c√°ch t·∫°o ra m·ªôt v√†i 'mode' (ki·ªÉu) d·ªØ li·ªáu h·∫°n ch·∫ø m√† c√≥ th·ªÉ ƒë√°nh l·ª´a Discriminator, d·∫´n ƒë·∫øn c√°c m·∫´u sinh ra thi·∫øu s·ª± ƒëa d·∫°ng v√† kh√¥ng bao qu√°t ƒë∆∞·ª£c to√†n b·ªô ph√¢n ph·ªëi d·ªØ li·ªáu th·∫≠t.",
        difficulty: "Medium"
    },
    {
        question: "Ki·∫øn tr√∫c DCGAN (Deep Convolutional GAN) c√≥ ƒë·∫∑c ƒëi·ªÉm n·ªïi b·∫≠t n√†o so v·ªõi GAN g·ªëc?",
        options: ["A) S·ª≠ d·ª•ng c√°c l·ªõp Fully Connected thay v√¨ Convolutional", "B) Lo·∫°i b·ªè ho√†n to√†n Discriminator", "C) S·ª≠ d·ª•ng c√°c l·ªõp Convolutional trong c·∫£ Generator v√† Discriminator, kh√¥ng c√≥ l·ªõp Pooling/Unpooling r√µ r√†ng (thay b·∫±ng strided convolutions v√† transpose convolutions)", "D) Ch·ªâ ho·∫°t ƒë·ªông v·ªõi d·ªØ li·ªáu vƒÉn b·∫£n"],
        correct: 2,
        explanation: "DCGAN gi·ªõi thi·ªáu m·ªôt s·ªë h∆∞·ªõng d·∫´n ki·∫øn tr√∫c ƒë·ªÉ hu·∫•n luy·ªán GAN ·ªïn ƒë·ªãnh h∆°n, bao g·ªìm vi·ªác s·ª≠ d·ª•ng c√°c l·ªõp t√≠ch ch·∫≠p c√≥ s·∫£i b∆∞·ªõc (strided convolutions) trong Discriminator ƒë·ªÉ gi·∫£m chi·ªÅu v√† c√°c l·ªõp t√≠ch ch·∫≠p chuy·ªÉn v·ªã (transpose convolutions) trong Generator ƒë·ªÉ tƒÉng chi·ªÅu, thay th·∫ø c√°c l·ªõp pooling/unpooling.",
        difficulty: "Medium"
    },
    {
        question: "Trong YOLO, ƒë·∫ßu ra c·ªßa m·∫°ng th∆∞·ªùng l√† m·ªôt tensor 3D (Grid x Grid x Channels). M·ªói √¥ l∆∞·ªõi (grid cell) ch·ªãu tr√°ch nhi·ªám d·ª± ƒëo√°n ƒëi·ªÅu g√¨?",
        options: ["A) To√†n b·ªô c√°c ƒë·ªëi t∆∞·ª£ng trong ·∫£nh", "B) Ch·ªâ c√°c ƒë·ªëi t∆∞·ª£ng c√≥ t√¢m r∆°i v√†o √¥ l∆∞·ªõi ƒë√≥", "C) Ch·ªâ lo·∫°i c·ªßa ƒë·ªëi t∆∞·ª£ng", "D) Ch·ªâ m·ªôt pixel duy nh·∫•t c·ªßa ƒë·ªëi t∆∞·ª£ng"],
        correct: 1,
        explanation: "·∫¢nh ƒë·∫ßu v√†o ƒë∆∞·ª£c chia th√†nh m·ªôt l∆∞·ªõi SxS. N·∫øu t√¢m c·ªßa m·ªôt ƒë·ªëi t∆∞·ª£ng r∆°i v√†o m·ªôt √¥ l∆∞·ªõi n√†o ƒë√≥, √¥ l∆∞·ªõi ƒë√≥ s·∫Ω ch·ªãu tr√°ch nhi·ªám ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng ƒë√≥, bao g·ªìm d·ª± ƒëo√°n bounding box, ƒëi·ªÉm tin c·∫≠y v√† x√°c su·∫•t l·ªõp.",
        difficulty: "Medium"
    },
    {
        question: "Intersection over Union (IoU) trong ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c t√≠nh nh∆∞ th·∫ø n√†o?",
        options: ["A) T·ªïng di·ªán t√≠ch c·ªßa h·ªôp d·ª± ƒëo√°n v√† h·ªôp th·ª±c t·∫ø", "B) Di·ªán t√≠ch ph·∫ßn giao chia cho di·ªán t√≠ch ph·∫ßn h·ª£p c·ªßa h·ªôp d·ª± ƒëo√°n v√† h·ªôp th·ª±c t·∫ø", "C) T·ª∑ l·ªá gi·ªØa chi·ªÅu r·ªông v√† chi·ªÅu cao c·ªßa h·ªôp d·ª± ƒëo√°n", "D) Kho·∫£ng c√°ch Euclidean gi·ªØa t√¢m c·ªßa hai h·ªôp"],
        correct: 1,
        explanation: "IoU = Area(Overlap) / Area(Union). N√≥ ƒëo l∆∞·ªùng m·ª©c ƒë·ªô ch·ªìng ch√©o gi·ªØa bounding box d·ª± ƒëo√°n v√† bounding box th·ª±c t·∫ø (ground truth). Gi√° tr·ªã IoU cao cho th·∫•y d·ª± ƒëo√°n t·ªët.",
        difficulty: "Medium"
    },
    {
        question: "Non-Maximum Suppression (NMS) trong YOLO ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ l√†m g√¨?",
        options: ["A) ƒê·ªÉ tƒÉng s·ªë l∆∞·ª£ng bounding box d·ª± ƒëo√°n", "B) ƒê·ªÉ lo·∫°i b·ªè c√°c bounding box d·ª± ƒëo√°n tr√πng l·∫∑p ho·∫∑c c√≥ ƒë·ªô tin c·∫≠y th·∫•p, gi·ªØ l·∫°i c√°c h·ªôp t·ªët nh·∫•t", "C) ƒê·ªÉ chu·∫©n h√≥a t·ªça ƒë·ªô c·ªßa bounding box", "D) ƒê·ªÉ tƒÉng t·ªëc ƒë·ªô x·ª≠ l√Ω c·ªßa Backbone"],
        correct: 1,
        explanation: "Sau khi m·∫°ng d·ª± ƒëo√°n nhi·ªÅu bounding box cho c√πng m·ªôt ƒë·ªëi t∆∞·ª£ng, NMS ƒë∆∞·ª£c √°p d·ª•ng ƒë·ªÉ lo·∫°i b·ªè c√°c h·ªôp d∆∞ th·ª´a. N√≥ gi·ªØ l·∫°i h·ªôp c√≥ ƒëi·ªÉm tin c·∫≠y cao nh·∫•t v√† lo·∫°i b·ªè c√°c h·ªôp kh√°c c√≥ IoU l·ªõn v·ªõi h·ªôp ƒë√≥.",
        difficulty: "Medium"
    },
    {
        question: "H√†m m·∫•t m√°t trong YOLO th∆∞·ªùng bao g·ªìm nh·ªØng th√†nh ph·∫ßn n√†o?",
        options: ["A) Ch·ªâ m·∫•t m√°t v·ªÅ v·ªã tr√≠ bounding box", "B) Ch·ªâ m·∫•t m√°t v·ªÅ ph√¢n lo·∫°i l·ªõp", "C) M·∫•t m√°t v·ªã tr√≠, m·∫•t m√°t ƒë·ªô tin c·∫≠y (objectness score), v√† m·∫•t m√°t ph√¢n lo·∫°i l·ªõp", "D) Ch·ªâ m·∫•t m√°t v·ªÅ k√≠ch th∆∞·ªõc ·∫£nh"],
        correct: 2,
        explanation: "H√†m m·∫•t m√°t c·ªßa YOLO l√† m·ªôt t·ªïng c√≥ tr·ªçng s·ªë c·ªßa nhi·ªÅu th√†nh ph·∫ßn: m·∫•t m√°t do sai l·ªách t·ªça ƒë·ªô bounding box, m·∫•t m√°t do sai l·ªách k√≠ch th∆∞·ªõc bounding box, m·∫•t m√°t v·ªÅ ƒëi·ªÉm tin c·∫≠y (objectness - li·ªáu c√≥ ƒë·ªëi t∆∞·ª£ng trong h·ªôp ƒë√≥ kh√¥ng), v√† m·∫•t m√°t v·ªÅ ph√¢n lo·∫°i l·ªõp c·ªßa ƒë·ªëi t∆∞·ª£ng.",
        difficulty: "Medium"
    },
    {
        question: "WGAN (Wasserstein GAN) s·ª≠ d·ª•ng h√†m m·∫•t m√°t n√†o ƒë·ªÉ c·∫£i thi·ªán s·ª± ·ªïn ƒë·ªãnh so v·ªõi GAN g·ªëc?",
        options: ["A) Minimax Loss v·ªõi h√†m Sigmoid", "B) Kho·∫£ng c√°ch Wasserstein (Earth Mover's Distance) v√† critic thay v√¨ discriminator", "C) Focal Loss", "D) L1 Loss"],
        correct: 1,
        explanation: "WGAN s·ª≠ d·ª•ng kho·∫£ng c√°ch Wasserstein ƒë·ªÉ ƒëo s·ª± kh√°c bi·ªát gi·ªØa ph√¢n ph·ªëi d·ªØ li·ªáu th·∫≠t v√† gi·∫£. Discriminator ƒë∆∞·ª£c thay th·∫ø b·∫±ng m·ªôt 'critic' kh√¥ng c√≥ h√†m Sigmoid ·ªü cu·ªëi v√† ƒë∆∞·ª£c hu·∫•n luy·ªán ƒë·ªÉ ∆∞·ªõc l∆∞·ª£ng kho·∫£ng c√°ch n√†y. ƒêi·ªÅu n√†y gi√∫p gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ vanishing gradients v√† mode collapse t·ªët h∆°n.",
        difficulty: "Medium"
    },
    {
        question: "Trong ki·∫øn tr√∫c YOLO, ph·∫ßn 'Neck' (v√≠ d·ª•: FPN, PANet) c√≥ vai tr√≤ g√¨?",
        options: ["A) Ch·ªâ tƒÉng s·ªë k√™nh c·ªßa feature map", "B) K·∫øt h·ª£p c√°c feature map t·ª´ c√°c t·∫ßng kh√°c nhau c·ªßa Backbone ƒë·ªÉ t·∫°o feature pyramid, gi√∫p ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng ·ªü nhi·ªÅu t·ª∑ l·ªá", "C) Th·ª±c hi·ªán Non-Maximum Suppression", "D) L√† l·ªõp output cu·ªëi c√πng"],
        correct: 1,
        explanation: "Neck l·∫•y c√°c feature map t·ª´ c√°c m·ª©c kh√°c nhau c·ªßa Backbone, sau ƒë√≥ k·∫øt h·ª£p v√† tinh ch·ªânh ch√∫ng (th∆∞·ªùng qua c√°c k·∫øt n·ªëi top-down v√† bottom-up) ƒë·ªÉ t·∫°o ra m·ªôt t·∫≠p h·ª£p c√°c feature map m·ªõi gi√†u th√¥ng tin h∆°n v√† ·ªü nhi·ªÅu t·ª∑ l·ªá kh√°c nhau, r·∫•t quan tr·ªçng ƒë·ªÉ ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng c√≥ k√≠ch th∆∞·ªõc ƒëa d·∫°ng.",
        difficulty: "Medium"
    },
    {
        question: "Conditional GAN (cGAN) kh√°c GAN c∆° b·∫£n ·ªü ƒëi·ªÉm n√†o?",
        options: ["A) cGAN kh√¥ng c√≥ Discriminator", "B) cGAN cho ph√©p Generator v√† Discriminator nh·∫≠n th√™m th√¥ng tin ƒëi·ªÅu ki·ªán (v√≠ d·ª•: nh√£n l·ªõp) ƒë·ªÉ ki·ªÉm so√°t vi·ªác t·∫°o m·∫´u", "C) cGAN ch·ªâ t·∫°o ra ·∫£nh ƒëen tr·∫Øng", "D) cGAN lu√¥n h·ªôi t·ª• nhanh h∆°n GAN c∆° b·∫£n"],
        correct: 1,
        explanation: "cGAN cho ph√©p ƒëi·ªÅu khi·ªÉn qu√° tr√¨nh sinh d·ªØ li·ªáu b·∫±ng c√°ch cung c·∫•p th√™m th√¥ng tin ƒëi·ªÅu ki·ªán (y) cho c·∫£ Generator G(z,y) v√† Discriminator D(x,y). V√≠ d·ª•, c√≥ th·ªÉ y√™u c·∫ßu GAN t·∫°o ·∫£nh c·ªßa m·ªôt l·ªõp c·ª• th·ªÉ.",
        difficulty: "Medium"
    },
    {
        question: "T·∫°i sao vi·ªác hu·∫•n luy·ªán GAN th∆∞·ªùng ƒë∆∞·ª£c coi l√† kh√≥ khƒÉn v√† kh√¥ng ·ªïn ƒë·ªãnh?",
        options: ["A) V√¨ ch√∫ng y√™u c·∫ßu qu√° nhi·ªÅu d·ªØ li·ªáu", "B) V√¨ Generator v√† Discriminator ph·∫£i ƒë·∫°t ƒë∆∞·ª£c m·ªôt ƒëi·ªÉm c√¢n b·∫±ng Nash, ƒëi·ªÅu n√†y kh√≥ t√¨m v√† duy tr√¨", "C) V√¨ ch√∫ng ch·ªâ ho·∫°t ƒë·ªông t·ªët tr√™n ·∫£nh c√≥ ƒë·ªô ph√¢n gi·∫£i th·∫•p", "D) V√¨ ch√∫ng kh√¥ng s·ª≠ d·ª•ng h√†m k√≠ch ho·∫°t phi tuy·∫øn"],
        correct: 1,
        explanation: "Hu·∫•n luy·ªán GAN l√† m·ªôt b√†i to√°n t√¨m ƒëi·ªÉm c√¢n b·∫±ng trong m·ªôt tr√≤ ch∆°i minimax gi·ªØa hai m·∫°ng. Vi·ªác ƒë·∫°t ƒë∆∞·ª£c s·ª± c√¢n b·∫±ng n√†y r·∫•t nh·∫°y c·∫£m v·ªõi ki·∫øn tr√∫c m·∫°ng, si√™u tham s·ªë v√† qu√° tr√¨nh t·ªëi ∆∞u, d·ªÖ d·∫´n ƒë·∫øn c√°c v·∫•n ƒë·ªÅ nh∆∞ mode collapse ho·∫∑c vanishing gradients.",
        difficulty: "Medium"
    },
     {
        question: "CycleGAN l√† m·ªôt lo·∫°i GAN ƒë∆∞·ª£c thi·∫øt k·∫ø cho t√°c v·ª• n√†o?",
        options: ["A) Sinh ·∫£nh si√™u ph√¢n gi·∫£i (Super-Resolution)", "B) Chuy·ªÉn ƒë·ªïi style gi·ªØa hai domain ·∫£nh kh√¥ng c·∫ßn c·∫∑p d·ªØ li·ªáu t∆∞∆°ng ·ª©ng (Unpaired Image-to-Image Translation)", "C) Ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng trong video", "D) N√©n ·∫£nh"],
        correct: 1,
        explanation: "CycleGAN n·ªïi ti·∫øng v·ªõi kh·∫£ nƒÉng h·ªçc √°nh x·∫° gi·ªØa hai domain ·∫£nh m√† kh√¥ng c·∫ßn c√°c c·∫∑p ·∫£nh t∆∞∆°ng ·ª©ng (paired data). V√≠ d·ª•, chuy·ªÉn ·∫£nh ng·ª±a th√†nh ng·ª±a v·∫±n, ho·∫∑c ·∫£nh m√πa h√® th√†nh m√πa ƒë√¥ng, d·ª±a tr√™n vi·ªác h·ªçc t√≠nh nh·∫•t qu√°n v√≤ng l·∫∑p (cycle consistency).",
        difficulty: "Medium"
    },
    {
        question: "Trong YOLO, mAP (mean Average Precision) l√† m·ªôt th∆∞·ªõc ƒëo quan tr·ªçng. N√≥ ƒë√°nh gi√° ƒëi·ªÅu g√¨?",
        options: ["A) T·ªëc ƒë·ªô x·ª≠ l√Ω ·∫£nh c·ªßa m√¥ h√¨nh", "B) ƒê·ªô ch√≠nh x√°c t·ªïng th·ªÉ c·ªßa m√¥ h√¨nh trong vi·ªác ph√°t hi·ªán v√† ph√¢n lo·∫°i ƒë·ªëi t∆∞·ª£ng tr√™n nhi·ªÅu ng∆∞·ª°ng IoU v√† nhi·ªÅu l·ªõp", "C) K√≠ch th∆∞·ªõc b·ªô nh·ªõ m√† m√¥ h√¨nh chi·∫øm d·ª•ng", "D) S·ªë l∆∞·ª£ng ƒë·ªëi t∆∞·ª£ng t·ªëi ƒëa m√¥ h√¨nh c√≥ th·ªÉ ph√°t hi·ªán"],
        correct: 1,
        explanation: "mAP l√† gi√° tr·ªã trung b√¨nh c·ªßa Average Precision (AP) qua t·∫•t c·∫£ c√°c l·ªõp ƒë·ªëi t∆∞·ª£ng. AP cho m·ªôt l·ªõp ƒë∆∞·ª£c t√≠nh t·ª´ ƒë∆∞·ªùng cong Precision-Recall, th·ªÉ hi·ªán kh·∫£ nƒÉng c·ªßa m√¥ h√¨nh trong vi·ªác c√¢n b·∫±ng gi·ªØa ƒë·ªô ch√≠nh x√°c (precision) v√† ƒë·ªô ph·ªß (recall) khi ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng c·ªßa l·ªõp ƒë√≥. Th∆∞·ªùng ƒë∆∞·ª£c t√≠nh tr√™n nhi·ªÅu ng∆∞·ª°ng IoU.",
        difficulty: "Medium"
    },
    {
        question: "K·ªπ thu·∫≠t Data Augmentation c√≥ l·ª£i √≠ch g√¨ khi hu·∫•n luy·ªán m√¥ h√¨nh YOLO?",
        options: ["A) Gi·∫£m s·ªë l∆∞·ª£ng anchor box c·∫ßn thi·∫øt", "B) TƒÉng k√≠ch th∆∞·ªõc hi·ªáu d·ª•ng c·ªßa t·∫≠p hu·∫•n luy·ªán, gi√∫p m√¥ h√¨nh t·ªïng qu√°t h√≥a t·ªët h∆°n v√† gi·∫£m overfitting", "C) L√†m cho qu√° tr√¨nh Non-Maximum Suppression nhanh h∆°n", "D) Thay th·∫ø ho√†n to√†n nhu c·∫ßu v·ªÅ m·ªôt Backbone m·∫°nh"],
        correct: 1,
        explanation: "Data augmentation t·∫°o ra c√°c bi·∫øn th·ªÉ c·ªßa d·ªØ li·ªáu hu·∫•n luy·ªán g·ªëc (v√≠ d·ª•: xoay, l·∫≠t, thay ƒë·ªïi m√†u s·∫Øc, c·∫Øt x√©n ·∫£nh) ƒë·ªÉ m√¥ h√¨nh h·ªçc ƒë∆∞·ª£c c√°c ƒë·∫∑c tr∆∞ng b·∫•t bi·∫øn h∆°n v√† ch·ªëng l·∫°i overfitting, ƒë·∫∑c bi·ªát khi d·ªØ li·ªáu g·ªëc h·∫°n ch·∫ø.",
        difficulty: "Medium"
    },
    {
        question: "Ki·∫øn tr√∫c YOLO n√†o gi·ªõi thi·ªáu kh√°i ni·ªám CSPNet (Cross Stage Partial Network) v√†o Backbone ƒë·ªÉ c·∫£i thi·ªán hi·ªáu su·∫•t v√† gi·∫£m t√≠nh to√°n?",
        options: ["A) YOLOv1", "B) YOLOv2 (YOLO9000)", "C) YOLOv3", "D) YOLOv4 / YOLOv5 (v√† c√°c phi√™n b·∫£n sau)"],
        correct: 3,
        explanation: "CSPNet ƒë∆∞·ª£c t√≠ch h·ª£p v√†o Backbone (v√≠ d·ª• CSPDarknet53 trong YOLOv4) v√† Neck c·ªßa c√°c phi√™n b·∫£n YOLO sau n√†y (nh∆∞ YOLOv4, YOLOv5) ƒë·ªÉ gi·∫£m chi ph√≠ t√≠nh to√°n v√† c·∫£i thi·ªán lu·ªìng gradient, gi√∫p m√¥ h√¨nh h·ªçc hi·ªáu qu·∫£ h∆°n.",
        difficulty: "Medium"
    },
    {
        question: "Trong GAN, t·∫°i sao ƒë√¥i khi ng∆∞·ªùi ta s·ª≠ d·ª•ng one-sided label smoothing cho Discriminator?",
        options: ["A) ƒê·ªÉ l√†m cho Generator d·ªÖ d√†ng ƒë√°nh l·ª´a Discriminator h∆°n", "B) ƒê·ªÉ ngƒÉn Discriminator tr·ªü n√™n qu√° t·ª± tin v√†o c√°c d·ª± ƒëo√°n c·ªßa n√≥, gi√∫p ·ªïn ƒë·ªãnh qu√° tr√¨nh hu·∫•n luy·ªán", "C) ƒê·ªÉ tƒÉng t·ªëc ƒë·ªô h·ªôi t·ª• c·ªßa Discriminator", "D) ƒê·ªÉ gi·∫£m s·ªë l∆∞·ª£ng tham s·ªë c·ªßa Discriminator"],
        correct: 1,
        explanation: "One-sided label smoothing thay th·∫ø nh√£n '1' (cho d·ªØ li·ªáu th·∫≠t) b·∫±ng m·ªôt gi√° tr·ªã h∆°i nh·ªè h∆°n (v√≠ d·ª•: 0.9). ƒêi·ªÅu n√†y ngƒÉn Discriminator tr·ªü n√™n qu√° ch·∫Øc ch·∫Øn v·ªÅ c√°c quy·∫øt ƒë·ªãnh c·ªßa n√≥ ƒë·ªëi v·ªõi m·∫´u th·∫≠t, c√≥ th·ªÉ gi√∫p gi·∫£m vanishing gradients cho Generator v√† l√†m qu√° tr√¨nh hu·∫•n luy·ªán ·ªïn ƒë·ªãnh h∆°n.",
        difficulty: "Medium"
    },
    {
        question: "So v·ªõi Faster R-CNN, ∆∞u ƒëi·ªÉm ch√≠nh c·ªßa YOLO l√† g√¨?",
        options: ["A) Lu√¥n c√≥ mAP cao h∆°n tr√™n m·ªçi t·∫≠p d·ªØ li·ªáu", "B) Kh·∫£ nƒÉng ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng r·∫•t nh·ªè t·ªët h∆°n", "C) T·ªëc ƒë·ªô inference (suy lu·∫≠n) nhanh h∆°n ƒë√°ng k·ªÉ", "D) Ki·∫øn tr√∫c ƒë∆°n gi·∫£n h∆°n v√† d·ªÖ hu·∫•n luy·ªán h∆°n"],
        correct: 2,
        explanation: "YOLO (m·ªôt one-stage detector) x·ª≠ l√Ω to√†n b·ªô ·∫£nh m·ªôt l·∫ßn ƒë·ªÉ d·ª± ƒëo√°n bounding box v√† l·ªõp, trong khi Faster R-CNN (m·ªôt two-stage detector) c√≥ giai ƒëo·∫°n t·∫°o v√πng ƒë·ªÅ xu·∫•t (Region Proposal Network) ri√™ng bi·ªát. ƒêi·ªÅu n√†y l√†m cho YOLO nhanh h∆°n nhi·ªÅu, ph√π h·ª£p cho c√°c ·ª©ng d·ª•ng th·ªùi gian th·ª±c.",
        difficulty: "Medium"
    },
    {
        question: "StyleGAN n·ªïi ti·∫øng v·ªõi kh·∫£ nƒÉng n√†o?",
        options: ["A) Ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng trong ·∫£nh ngh·ªá thu·∫≠t", "B) Sinh ra ·∫£nh ch·∫•t l∆∞·ª£ng r·∫•t cao v√† c√≥ kh·∫£ nƒÉng ki·ªÉm so√°t c√°c thu·ªôc t√≠nh style c·ªßa ·∫£nh (v√≠ d·ª•: khu√¥n m·∫∑t, ki·ªÉu t√≥c)", "C) D·ªãch vƒÉn b·∫£n sang ·∫£nh", "D) N√©n video hi·ªáu qu·∫£"],
        correct: 1,
        explanation: "StyleGAN v√† c√°c phi√™n b·∫£n k·∫ø th·ª´a c·ªßa n√≥ (StyleGAN2, StyleGAN3) ƒë√£ ƒë·∫°t ƒë∆∞·ª£c nh·ªØng k·∫øt qu·∫£ ·∫•n t∆∞·ª£ng trong vi·ªác sinh ·∫£nh ch√¢n th·ª±c, ƒë·∫∑c bi·ªát l√† ·∫£nh khu√¥n m·∫∑t. Ch√∫ng cho ph√©p ki·ªÉm so√°t c√°c kh√≠a c·∫°nh kh√°c nhau c·ªßa style ·∫£nh ·ªü c√°c m·ª©c ƒë·ªô chi ti·∫øt kh√°c nhau th√¥ng qua vi·ªác ƒëi·ªÅu ch·ªânh c√°c vector latent.",
        difficulty: "Medium"
    },
     {
        question: "H√†m sigmoid ƒë∆∞·ª£c d√πng ·ªü l·ªõp cu·ªëi c·ªßa Discriminator trong GAN g·ªëc c√≥ th·ªÉ g√¢y ra v·∫•n ƒë·ªÅ g√¨?",
        options: ["A) Exploding gradients", "B) Vanishing gradients cho Generator khi Discriminator qu√° t·ª± tin", "C) Mode seeking behavior", "D) TƒÉng chi ph√≠ t√≠nh to√°n"],
        correct: 1,
        explanation: "Khi Discriminator tr·ªü n√™n r·∫•t gi·ªèi v√† c√°c d·ª± ƒëo√°n c·ªßa n√≥ (sau sigmoid) ti·∫øn g·∫ßn ƒë·∫øn 0 (cho m·∫´u gi·∫£) ho·∫∑c 1 (cho m·∫´u th·∫≠t), ƒë·∫°o h√†m c·ªßa h√†m sigmoid ·ªü c√°c v√πng n√†y r·∫•t nh·ªè. ƒêi·ªÅu n√†y l√†m cho gradient truy·ªÅn v·ªÅ Generator c≈©ng r·∫•t nh·ªè, g√¢y ra vanishing gradients v√† Generator kh√≥ h·ªçc.",
        difficulty: "Medium"
    },
    {
        question: "Trong YOLO, m·ªói anchor box th∆∞·ªùng ƒë∆∞·ª£c li√™n k·∫øt v·ªõi bao nhi√™u th√¥ng s·ªë d·ª± ƒëo√°n?",
        options: ["A) Ch·ªâ 1 (x√°c su·∫•t l·ªõp)", "B) 2 (t·ªça ƒë·ªô x, y)", "C) 4 (t·ªça ƒë·ªô x, y, w, h)", "D) 5 + s·ªë l·ªõp (4 cho bounding box, 1 cho objectness, v√† s·ªë l·ªõp cho class probabilities)"],
        correct: 3,
        explanation: "ƒê·ªëi v·ªõi m·ªói anchor box t·∫°i m·ªôt √¥ l∆∞·ªõi, YOLO th∆∞·ªùng d·ª± ƒëo√°n: 4 gi√° tr·ªã cho t·ªça ƒë·ªô v√† k√≠ch th∆∞·ªõc bounding box (v√≠ d·ª•: tx, ty, tw, th l√† ƒë·ªô l·ªách so v·ªõi anchor), 1 gi√° tr·ªã cho ƒëi·ªÉm tin c·∫≠y (objectness score), v√† C gi√° tr·ªã cho x√°c su·∫•t c·ªßa t·ª´ng l·ªõp (n·∫øu c√≥ C l·ªõp).",
        difficulty: "Medium"
    },

    // --- HARD (15 c√¢u) ---
    {
        question: "Wasserstein GAN (WGAN) gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ vanishing gradients trong GAN g·ªëc b·∫±ng c√°ch n√†o?",
        options: ["A) S·ª≠ d·ª•ng m·ªôt Generator ph·ª©c t·∫°p h∆°n", "B) Lo·∫°i b·ªè h√†m sigmoid ·ªü l·ªõp cu·ªëi c·ªßa critic v√† s·ª≠ d·ª•ng h√†m m·∫•t m√°t d·ª±a tr√™n kho·∫£ng c√°ch Wasserstein, ƒë·ªìng th·ªùi √©p bu·ªôc ƒëi·ªÅu ki·ªán Lipschitz cho critic", "C) Th√™m nhi·ªÖu v√†o ƒë·∫ßu v√†o c·ªßa Discriminator", "D) S·ª≠ d·ª•ng nhi·ªÅu Discriminator"],
        correct: 1,
        explanation: "WGAN thay th·∫ø h√†m m·∫•t m√°t minimax b·∫±ng m·ªôt h√†m m·∫•t m√°t d·ª±a tr√™n kho·∫£ng c√°ch Wasserstein (∆∞·ªõc l∆∞·ª£ng b·∫±ng output c·ªßa critic). Critic kh√¥ng c√≥ sigmoid ·ªü cu·ªëi. ƒê·ªÉ ƒë·∫£m b·∫£o critic ∆∞·ªõc l∆∞·ª£ng ƒë√∫ng kho·∫£ng c√°ch Wasserstein, tr·ªçng s·ªë c·ªßa n√≥ ph·∫£i b·ªã r√†ng bu·ªôc (v√≠ d·ª•: weight clipping ho·∫∑c gradient penalty) ƒë·ªÉ th·ªèa m√£n ƒëi·ªÅu ki·ªán Lipschitz. ƒêi·ªÅu n√†y cung c·∫•p gradient ·ªïn ƒë·ªãnh h∆°n cho Generator.",
        difficulty: "Hard"
    },
    {
        question: "K·ªπ thu·∫≠t 'weight clipping' trong WGAN g·ªëc c√≥ th·ªÉ d·∫´n ƒë·∫øn nh·ªØng v·∫•n ƒë·ªÅ g√¨?",
        options: ["A) Lu√¥n d·∫´n ƒë·∫øn mode collapse", "B) C√≥ th·ªÉ khi·∫øn critic h·ªçc c√°c h√†m qu√° ƒë∆°n gi·∫£n ho·∫∑c l√†m gradient b·ªã b√£o h√≤a/bi·∫øn m·∫•t ·ªü c√°c gi√° tr·ªã bi√™n", "C) L√†m tƒÉng ƒë√°ng k·ªÉ th·ªùi gian hu·∫•n luy·ªán cho m·ªói epoch", "D) Y√™u c·∫ßu k√≠ch th∆∞·ªõc batch r·∫•t l·ªõn"],
        correct: 1,
        explanation: "Weight clipping √©p bu·ªôc c√°c tr·ªçng s·ªë c·ªßa critic n·∫±m trong m·ªôt kho·∫£ng c·ªë ƒë·ªãnh (v√≠ d·ª• [-c, c]). N·∫øu c qu√° nh·ªè, critic c√≥ th·ªÉ b·ªã ƒë·∫©y v·ªÅ ph√≠a c√°c h√†m ƒë∆°n gi·∫£n, h·∫°n ch·∫ø kh·∫£ nƒÉng h·ªçc. N·∫øu c qu√° l·ªõn, m·∫•t nhi·ªÅu th·ªùi gian ƒë·ªÉ tr·ªçng s·ªë ƒë·∫°t ƒë·∫øn gi·ªõi h·∫°n, v√† gradient c√≥ th·ªÉ b·ªã b√£o h√≤a ·ªü c√°c gi√° tr·ªã bi√™n, l√†m ch·∫≠m qu√° tr√¨nh h·ªçc.",
        difficulty: "Hard"
    },
    {
        question: "Gradient Penalty trong WGAN-GP ƒë∆∞·ª£c t√≠nh to√°n nh∆∞ th·∫ø n√†o?",
        options: ["A) D·ª±a tr√™n norm c·ªßa tr·ªçng s·ªë c·ªßa critic", "B) D·ª±a tr√™n s·ª± kh√°c bi·ªát gi·ªØa output c·ªßa critic cho m·∫´u th·∫≠t v√† m·∫´u gi·∫£", "C) D·ª±a tr√™n norm c·ªßa gradient c·ªßa critic ƒë·ªëi v·ªõi c√°c ƒëi·ªÉm n·ªôi suy ng·∫´u nhi√™n gi·ªØa c√°c c·∫∑p m·∫´u th·∫≠t v√† m·∫´u gi·∫£", "D) B·∫±ng c√°ch th√™m nhi·ªÖu Gaussian v√†o gradient c·ªßa critic"],
        correct: 2,
        explanation: "Gradient Penalty (GP) trong WGAN-GP ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ √©p bu·ªôc ƒëi·ªÅu ki·ªán 1-Lipschitz m·ªôt c√°ch 'm·ªÅm m·∫°i'. N√≥ t√≠nh to√°n gradient c·ªßa output c·ªßa critic ƒë·ªëi v·ªõi c√°c ƒëi·ªÉm ƒë·∫ßu v√†o ƒë∆∞·ª£c n·ªôi suy tuy·∫øn t√≠nh ng·∫´u nhi√™n gi·ªØa c√°c m·∫´u t·ª´ ph√¢n ph·ªëi d·ªØ li·ªáu th·∫≠t v√† ph√¢n ph·ªëi d·ªØ li·ªáu sinh ra. Sau ƒë√≥, n√≥ ph·∫°t n·∫øu norm c·ªßa c√°c gradient n√†y kh√°c xa 1.",
        difficulty: "Hard"
    },
    {
        question: "Trong ki·∫øn tr√∫c YOLOv3, vi·ªác s·ª≠ d·ª•ng feature pyramid ·ªü 3 t·ª∑ l·ªá kh√°c nhau nh·∫±m m·ª•c ƒë√≠ch g√¨?",
        options: ["A) ƒê·ªÉ tƒÉng t·ªëc ƒë·ªô x·ª≠ l√Ω ·∫£nh", "B) ƒê·ªÉ ph√°t hi·ªán c√°c ƒë·ªëi t∆∞·ª£ng c√≥ k√≠ch th∆∞·ªõc kh√°c nhau m·ªôt c√°ch hi·ªáu qu·∫£ h∆°n (ƒë·ªëi t∆∞·ª£ng nh·ªè ·ªü feature map ƒë·ªô ph√¢n gi·∫£i cao, ƒë·ªëi t∆∞·ª£ng l·ªõn ·ªü feature map ƒë·ªô ph√¢n gi·∫£i th·∫•p)", "C) ƒê·ªÉ gi·∫£m s·ªë l∆∞·ª£ng anchor box c·∫ßn thi·∫øt", "D) ƒê·ªÉ cho ph√©p m√¥ h√¨nh ho·∫°t ƒë·ªông tr√™n nhi·ªÅu lo·∫°i ·∫£nh kh√°c nhau"],
        correct: 1,
        explanation: "YOLOv3 d·ª± ƒëo√°n bounding box tr√™n 3 feature map ·ªü c√°c t·ª∑ l·ªá kh√°c nhau. Feature map c√≥ ƒë·ªô ph√¢n gi·∫£i cao h∆°n (k√≠ch th∆∞·ªõc l·ªõn h∆°n) ph√π h·ª£p ƒë·ªÉ ph√°t hi·ªán c√°c ƒë·ªëi t∆∞·ª£ng nh·ªè, trong khi feature map c√≥ ƒë·ªô ph√¢n gi·∫£i th·∫•p h∆°n (k√≠ch th∆∞·ªõc nh·ªè h∆°n, nh∆∞ng tr∆∞·ªùng nh√¨n r·ªông h∆°n) ph√π h·ª£p ƒë·ªÉ ph√°t hi·ªán c√°c ƒë·ªëi t∆∞·ª£ng l·ªõn.",
        difficulty: "Hard"
    },
    {
        question: "H√†m m·∫•t m√°t Focal Loss ƒë∆∞·ª£c gi·ªõi thi·ªáu trong b√†i b√°o n√†o v√† nh·∫±m gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ g√¨ trong ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng?",
        options: ["A) YOLOv1, gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ bounding box kh√¥ng ch√≠nh x√°c", "B) Faster R-CNN, gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ v√πng ƒë·ªÅ xu·∫•t ch·∫≠m", "C) RetinaNet, gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ m·∫•t c√¢n b·∫±ng gi·ªØa c√°c m·∫´u easy negative v√† hard positive trong one-stage detectors", "D) SSD, gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng nh·ªè"],
        correct: 2,
        explanation: "Focal Loss ƒë∆∞·ª£c gi·ªõi thi·ªáu trong b√†i b√°o v·ªÅ RetinaNet. N√≥ ƒëi·ªÅu ch·ªânh h√†m cross-entropy ti√™u chu·∫©n ƒë·ªÉ gi·∫£m tr·ªçng s·ªë c·ªßa c√°c m·∫´u d·ªÖ ph√¢n lo·∫°i (th∆∞·ªùng l√† c√°c anchor box n·ªÅn chi·∫øm ƒëa s·ªë) v√† t·∫≠p trung h∆°n v√†o c√°c m·∫´u kh√≥ ph√¢n lo·∫°i (ƒë·ªëi t∆∞·ª£ng). ƒêi·ªÅu n√†y gi√∫p c√°c b·ªô ph√°t hi·ªán m·ªôt giai ƒëo·∫°n ƒë·∫°t ƒë∆∞·ª£c ƒë·ªô ch√≠nh x√°c t∆∞∆°ng ƒë∆∞∆°ng c√°c b·ªô ph√°t hi·ªán hai giai ƒëo·∫°n.",
        difficulty: "Hard"
    },
    {
        question: "Progressive Growing of GANs (PGGAN) l√† m·ªôt k·ªπ thu·∫≠t gi√∫p hu·∫•n luy·ªán GAN sinh ·∫£nh ƒë·ªô ph√¢n gi·∫£i cao b·∫±ng c√°ch n√†o?",
        options: ["A) S·ª≠ d·ª•ng nhi·ªÅu Discriminator c√πng l√∫c", "B) TƒÉng d·∫ßn k√≠ch th∆∞·ªõc batch trong qu√° tr√¨nh hu·∫•n luy·ªán", "C) B·∫Øt ƒë·∫ßu hu·∫•n luy·ªán Generator v√† Discriminator v·ªõi ·∫£nh ƒë·ªô ph√¢n gi·∫£i th·∫•p, sau ƒë√≥ t·ª´ t·ª´ th√™m c√°c l·ªõp m·ªõi ƒë·ªÉ tƒÉng ƒë·ªô ph√¢n gi·∫£i ·∫£nh sinh ra v√† ·∫£nh th·∫≠t", "D) Ch·ªâ hu·∫•n luy·ªán Generator, gi·ªØ Discriminator c·ªë ƒë·ªãnh"],
        correct: 2,
        explanation: "PGGAN b·∫Øt ƒë·∫ßu b·∫±ng vi·ªác hu·∫•n luy·ªán GAN tr√™n ·∫£nh c√≥ ƒë·ªô ph√¢n gi·∫£i r·∫•t th·∫•p (v√≠ d·ª• 4x4). Khi qu√° tr√¨nh hu·∫•n luy·ªán ·ªïn ƒë·ªãnh, c√°c l·ªõp m·ªõi ƒë∆∞·ª£c th√™m t·ª´ t·ª´ v√†o c·∫£ Generator v√† Discriminator ƒë·ªÉ tƒÉng g·∫•p ƒë√¥i ƒë·ªô ph√¢n gi·∫£i. Qu√° tr√¨nh n√†y l·∫∑p l·∫°i cho ƒë·∫øn khi ƒë·∫°t ƒë∆∞·ª£c ƒë·ªô ph√¢n gi·∫£i mong mu·ªën. ƒêi·ªÅu n√†y gi√∫p ·ªïn ƒë·ªãnh qu√° tr√¨nh h·ªçc v√† cho ph√©p sinh ·∫£nh ch·∫•t l∆∞·ª£ng cao.",
        difficulty: "Hard"
    },
    {
        question: "Trong StyleGAN, 'mapping network' c√≥ vai tr√≤ g√¨?",
        options: ["A) √Ånh x·∫° ·∫£nh ƒë·∫ßu v√†o sang m·ªôt kh√¥ng gian latent Z", "B) √Ånh x·∫° m·ªôt vector latent Z (th∆∞·ªùng t·ª´ ph√¢n ph·ªëi chu·∫©n) sang m·ªôt kh√¥ng gian latent trung gian W, kh√¥ng gian n√†y √≠t b·ªã 'v∆∞·ªõng v√≠u' (disentangled) h∆°n", "C) Th·ª±c hi·ªán Non-Maximum Suppression", "D) T·∫°o ra c√°c anchor box"],
        correct: 1,
        explanation: "Mapping network trong StyleGAN l√† m·ªôt chu·ªói c√°c l·ªõp fully connected, nh·∫≠n ƒë·∫ßu v√†o l√† vector latent z (th∆∞·ªùng ƒë∆∞·ª£c l·∫•y m·∫´u t·ª´ ph√¢n ph·ªëi Gaussian) v√† bi·∫øn ƒë·ªïi n√≥ th√†nh m·ªôt vector latent trung gian w thu·ªôc kh√¥ng gian W. Kh√¥ng gian W ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ c√°c y·∫øu t·ªë bi·∫øn thi√™n c·ªßa d·ªØ li·ªáu √≠t b·ªã 'v∆∞·ªõng v√≠u' (entangled) h∆°n so v·ªõi kh√¥ng gian Z, cho ph√©p ki·ªÉm so√°t c√°c thu·ªôc t√≠nh style c·ªßa ·∫£nh sinh ra t·ªët h∆°n.",
        difficulty: "Hard"
    },
    {
        question: "PANet (Path Aggregation Network), th∆∞·ªùng ƒë∆∞·ª£c d√πng l√†m Neck trong c√°c phi√™n b·∫£n YOLO, c·∫£i ti·∫øn FPN (Feature Pyramid Network) nh∆∞ th·∫ø n√†o?",
        options: ["A) Ch·ªâ s·ª≠ d·ª•ng k·∫øt n·ªëi top-down", "B) Th√™m m·ªôt ƒë∆∞·ªùng d·∫´n bottom-up tƒÉng c∆∞·ªùng sau ƒë∆∞·ªùng d·∫´n top-down c·ªßa FPN, gi√∫p truy·ªÅn th√¥ng tin c·ª•c b·ªô m·∫°nh m·∫Ω h∆°n", "C) Lo·∫°i b·ªè ho√†n to√†n c√°c l·ªõp t√≠ch ch·∫≠p", "D) Gi·∫£m s·ªë l∆∞·ª£ng feature map ·ªü m·ªói t·ª∑ l·ªá"],
        correct: 1,
        explanation: "FPN ch·ªß y·∫øu s·ª≠ d·ª•ng ƒë∆∞·ªùng d·∫´n top-down ƒë·ªÉ k·∫øt h·ª£p c√°c feature map ƒëa t·ª∑ l·ªá. PANet c·∫£i ti·∫øn ƒëi·ªÅu n√†y b·∫±ng c√°ch th√™m m·ªôt ƒë∆∞·ªùng d·∫´n bottom-up augmentation sau ƒë√≥. ƒê∆∞·ªùng d·∫´n bottom-up n√†y gi√∫p truy·ªÅn c√°c t√≠n hi·ªáu ƒë·∫∑c tr∆∞ng c·ª•c b·ªô m·∫°nh t·ª´ c√°c l·ªõp n√¥ng h∆°n l√™n c√°c feature map s√¢u h∆°n, b·ªï sung cho th√¥ng tin ng·ªØ nghƒ©a t·ª´ ƒë∆∞·ªùng d·∫´n top-down.",
        difficulty: "Hard"
    },
     {
        question: "Self-Attention trong Transformer c√≥ ƒë·ªô ph·ª©c t·∫°p t√≠nh to√°n l√† bao nhi√™u ƒë·ªëi v·ªõi m·ªôt chu·ªói c√≥ ƒë·ªô d√†i N?",
        options: ["A) O(N)", "B) O(N log N)", "C) O(N^2)", "D) O(N^3)"],
        correct: 2,
        explanation: "Trong self-attention, m·ªói token c·∫ßn t√≠nh to√°n ƒëi·ªÉm ch√∫ √Ω v·ªõi t·∫•t c·∫£ N token kh√°c (bao g·ªìm ch√≠nh n√≥). Vi·ªác t√≠nh to√°n ma tr·∫≠n attention scores (Q.K^T) c√≥ ƒë·ªô ph·ª©c t·∫°p O(N^2 * d), trong ƒë√≥ d l√† s·ªë chi·ªÅu c·ªßa key/query. Do ƒë√≥, ƒë·ªô ph·ª©c t·∫°p t·ªïng th·ªÉ l√† b·∫≠c hai theo ƒë·ªô d√†i chu·ªói N.",
        difficulty: "Hard"
    },
    {
        question: "Ki·∫øn tr√∫c Transformer s·ª≠ d·ª•ng c∆° ch·∫ø n√†o ƒë·ªÉ x·ª≠ l√Ω th√¥ng tin v·ªÅ v·ªã tr√≠ c·ªßa c√°c token trong chu·ªói, do self-attention v·ªën kh√¥ng nh·∫°y c·∫£m v·ªõi th·ª© t·ª±?",
        options: ["A) Convolutional layers", "B) Recurrent Neural Networks (RNNs)", "C) Positional Encoding", "D) B·ªè qua th√¥ng tin v·ªã tr√≠"],
        correct: 2,
        explanation: "V√¨ self-attention x·ª≠ l√Ω c√°c token m·ªôt c√°ch song song v√† kh√¥ng c√≥ th√¥ng tin v·ªÅ th·ª© t·ª±, Transformer th√™m c√°c vector Positional Encoding v√†o embedding c·ªßa m·ªói token ƒë·ªÉ cung c·∫•p th√¥ng tin v·ªÅ v·ªã tr√≠ tuy·ªát ƒë·ªëi ho·∫∑c t∆∞∆°ng ƒë·ªëi c·ªßa ch√∫ng trong chu·ªói.",
        difficulty: "Hard"
    },
    {
        question: "Trong c√°c m√¥ h√¨nh GAN, vi·ªác s·ª≠ d·ª•ng Batch Normalization cho c·∫£ Generator v√† Discriminator c√≥ th·ªÉ g√¢y ra v·∫•n ƒë·ªÅ g√¨ n·∫øu kh√¥ng c·∫©n th·∫≠n?",
        options: ["A) Lu√¥n l√†m gi·∫£m ch·∫•t l∆∞·ª£ng ·∫£nh sinh ra", "B) C√≥ th·ªÉ g√¢y ra t∆∞∆°ng quan kh√¥ng mong mu·ªën gi·ªØa c√°c m·∫´u trong c√πng m·ªôt batch, l√†m gi·∫£m s·ª± ƒëa d·∫°ng c·ªßa m·∫´u sinh ra ho·∫∑c g√¢y b·∫•t ·ªïn", "C) TƒÉng ƒë√°ng k·ªÉ th·ªùi gian hu·∫•n luy·ªán m√† kh√¥ng c·∫£i thi·ªán hi·ªáu su·∫•t", "D) Khi·∫øn Discriminator lu√¥n th·∫Øng Generator"],
        correct: 1,
        explanation: "Batch Normalization chu·∫©n h√≥a theo batch. Trong Generator, n·∫øu c√°c m·∫´u trong c√πng m·ªôt batch tr·ªü n√™n t∆∞∆°ng quan do BN, n√≥ c√≥ th·ªÉ h·∫°n ch·∫ø s·ª± ƒëa d·∫°ng. Trong Discriminator, vi·ªác BN tr√™n c·∫£ m·∫´u th·∫≠t v√† gi·∫£ trong c√πng batch c√≥ th·ªÉ r√≤ r·ªâ th√¥ng tin, l√†m ·∫£nh h∆∞·ªüng ƒë·∫øn vi·ªác h·ªçc. C√°c k·ªπ thu·∫≠t nh∆∞ Instance Normalization ho·∫∑c Layer Normalization ƒë√¥i khi ƒë∆∞·ª£c ∆∞u ti√™n h∆°n trong GAN.",
        difficulty: "Hard"
    },
     {
        question: "So s√°nh YOLOv5 v√† c√°c phi√™n b·∫£n YOLO tr∆∞·ªõc ƒë√≥ (v√≠ d·ª• YOLOv3, YOLOv4), m·ªôt trong nh·ªØng thay ƒë·ªïi ƒë√°ng ch√∫ √Ω l√† g√¨?",
        options: ["A) YOLOv5 lo·∫°i b·ªè ho√†n to√†n anchor boxes", "B) YOLOv5 th∆∞·ªùng ƒë∆∞·ª£c tri·ªÉn khai b·∫±ng PyTorch v√† c√≥ c·∫•u tr√∫c module linh ho·∫°t h∆°n, d·ªÖ d√†ng t√πy ch·ªânh v√† hu·∫•n luy·ªán h∆°n", "C) YOLOv5 s·ª≠ d·ª•ng m·ªôt Backbone ho√†n to√†n m·ªõi d·ª±a tr√™n Transformer", "D) YOLOv5 ch·ªâ ho·∫°t ƒë·ªông t·ªët tr√™n GPU c·ªßa NVIDIA"],
        correct: 1,
        explanation: "YOLOv5 (v√† c√°c phi√™n b·∫£n sau c·ªßa n√≥) ƒë∆∞·ª£c ph√°t tri·ªÉn b·ªüi Ultralytics v√† ƒë∆∞·ª£c vi·∫øt b·∫±ng PyTorch, n·ªïi b·∫≠t v·ªõi c·∫•u tr√∫c d·ªÖ s·ª≠ d·ª•ng, hu·∫•n luy·ªán v√† tri·ªÉn khai. N√≥ ti·∫øp t·ª•c s·ª≠ d·ª•ng anchor boxes (m·∫∑c d√π c√≥ c∆° ch·∫ø t·ª± ƒë·ªông h·ªçc anchor). C√°c phi√™n b·∫£n YOLO tr∆∞·ªõc (v1-v4) c·ªßa Joseph Redmon ƒë∆∞·ª£c vi·∫øt b·∫±ng Darknet (C).",
        difficulty: "Hard"
    },
    {
        question: "Trong hu·∫•n luy·ªán GAN, t·∫°i sao vi·ªác c√¢n b·∫±ng t·ªëc ƒë·ªô h·ªçc gi·ªØa Generator v√† Discriminator l·∫°i quan tr·ªçng?",
        options: ["A) Kh√¥ng quan tr·ªçng, m·∫°ng n√†o h·ªçc nhanh h∆°n s·∫Ω t·ªët h∆°n", "B) N·∫øu m·ªôt m·∫°ng h·ªçc qu√° nhanh so v·ªõi m·∫°ng kia, qu√° tr√¨nh hu·∫•n luy·ªán c√≥ th·ªÉ kh√¥ng h·ªôi t·ª• ho·∫∑c m·ªôt trong hai m·∫°ng s·∫Ω '√°p ƒë·∫£o' m·∫°ng c√≤n l·∫°i", "C) Ch·ªâ c·∫ßn Generator h·ªçc nhanh, Discriminator c√≥ th·ªÉ h·ªçc ch·∫≠m", "D) Vi·ªác n√†y ch·ªâ quan tr·ªçng ƒë·ªëi v·ªõi cGAN"],
        correct: 1,
        explanation: "GAN l√† m·ªôt tr√≤ ch∆°i minimax. N·∫øu Discriminator h·ªçc qu√° nhanh v√† tr·ªü n√™n qu√° gi·ªèi, Generator s·∫Ω kh√¥ng nh·∫≠n ƒë∆∞·ª£c gradient h·ªØu √≠ch ƒë·ªÉ c·∫£i thi·ªán. Ng∆∞·ª£c l·∫°i, n·∫øu Generator qu√° gi·ªèi v√† d·ªÖ d√†ng ƒë√°nh l·ª´a Discriminator, Discriminator s·∫Ω kh√¥ng cung c·∫•p ƒë∆∞·ª£c ph·∫£n h·ªìi ch√≠nh x√°c. Do ƒë√≥, vi·ªác c√¢n b·∫±ng t·ªëc ƒë·ªô h·ªçc (th∆∞·ªùng b·∫±ng c√°ch c·∫≠p nh·∫≠t m·ªôt m·∫°ng nhi·ªÅu l·∫ßn h∆°n m·∫°ng kia trong m·ªôt s·ªë tr∆∞·ªùng h·ª£p, ho·∫∑c ƒëi·ªÅu ch·ªânh learning rate) l√† r·∫•t quan tr·ªçng.",
        difficulty: "Hard"
    },
    {
        question: "Spectral Normalization l√† m·ªôt k·ªπ thu·∫≠t ƒë∆∞·ª£c √°p d·ª•ng cho c√°c tr·ªçng s·ªë c·ªßa Discriminator trong GAN nh·∫±m m·ª•c ƒë√≠ch g√¨?",
        options: ["A) TƒÉng t·ªëc ƒë·ªô t√≠nh to√°n c·ªßa Discriminator", "B) Gi·∫£m s·ªë l∆∞·ª£ng tham s·ªë c·ªßa Discriminator", "C) R√†ng bu·ªôc h·∫±ng s·ªë Lipschitz c·ªßa Discriminator, gi√∫p ·ªïn ƒë·ªãnh qu√° tr√¨nh hu·∫•n luy·ªán, t∆∞∆°ng t·ª± nh∆∞ Gradient Penalty nh∆∞ng theo c√°ch kh√°c", "D) Bu·ªôc c√°c tr·ªçng s·ªë ph·∫£i d∆∞∆°ng"],
        correct: 2,
        explanation: "Spectral Normalization chu·∫©n h√≥a ma tr·∫≠n tr·ªçng s·ªë c·ªßa m·ªói l·ªõp trong Discriminator b·∫±ng c√°ch chia cho gi√° tr·ªã ri√™ng (spectral norm) l·ªõn nh·∫•t c·ªßa n√≥. ƒêi·ªÅu n√†y gi√∫p r√†ng bu·ªôc h·∫±ng s·ªë Lipschitz c·ªßa Discriminator, l√†m cho h√†m n√†y 'm∆∞·ª£t m√†' h∆°n v√† qu√° tr√¨nh hu·∫•n luy·ªán GAN ·ªïn ƒë·ªãnh h∆°n, ƒë·∫∑c bi·ªát h·ªØu √≠ch trong c√°c m√¥ h√¨nh nh∆∞ SNGAN.",
        difficulty: "Hard"
    },
    {
        question: "YOLOX l√† m·ªôt phi√™n b·∫£n YOLO n·ªïi b·∫≠t v·ªõi vi·ªác lo·∫°i b·ªè th√†nh ph·∫ßn n√†o v√† thay th·∫ø b·∫±ng chi·∫øn l∆∞·ª£c g√°n nh√£n n√†o?",
        options: ["A) Lo·∫°i b·ªè Backbone, thay b·∫±ng Transformer Encoder", "B) Lo·∫°i b·ªè anchor boxes (anchor-free) v√† s·ª≠ d·ª•ng chi·∫øn l∆∞·ª£c g√°n nh√£n SimOTA", "C) Lo·∫°i b·ªè Neck, k·∫øt n·ªëi tr·ª±c ti·∫øp Backbone v·ªõi Head", "D) Lo·∫°i b·ªè Non-Maximum Suppression, thay b·∫±ng Soft-NMS"],
        correct: 1,
        explanation: "YOLOX l√† m·ªôt b·ªô ph√°t hi·ªán anchor-free, nghƒ©a l√† n√≥ kh√¥ng s·ª≠ d·ª•ng c√°c anchor box ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a tr∆∞·ªõc. Thay v√†o ƒë√≥, n√≥ tr·ª±c ti·∫øp d·ª± ƒëo√°n v·ªã tr√≠ v√† k√≠ch th∆∞·ªõc c·ªßa ƒë·ªëi t∆∞·ª£ng. YOLOX c≈©ng gi·ªõi thi·ªáu SimOTA, m·ªôt chi·∫øn l∆∞·ª£c g√°n nh√£n (label assignment) ti√™n ti·∫øn ƒë·ªÉ quy·∫øt ƒë·ªãnh √¥ l∆∞·ªõi n√†o ch·ªãu tr√°ch nhi·ªám cho ƒë·ªëi t∆∞·ª£ng n√†o trong qu√° tr√¨nh hu·∫•n luy·ªán, d·ª±a tr√™n s·ª± t·ªëi ∆∞u h√≥a chi ph√≠.",
        difficulty: "Hard"
    },

    // --- EXPERT (5 c√¢u) ---
    {
        question: "Trong StyleGAN2, k·ªπ thu·∫≠t 'modulated convolution' v√† 'demodulation' ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ l√†m g√¨?",
        options: ["A) ƒê·ªÉ gi·∫£m s·ªë l∆∞·ª£ng k√™nh trong c√°c l·ªõp t√≠ch ch·∫≠p", "B) ƒê·ªÉ cho ph√©p vector style (t·ª´ kh√¥ng gian W) ki·ªÉm so√°t c√°c ƒë·∫∑c tr∆∞ng ·ªü m·ªói l·ªõp t√≠ch ch·∫≠p m·ªôt c√°ch c·ª•c b·ªô m√† kh√¥ng g√¢y ra c√°c artifact (hi·ªán v·∫≠t) kh√¥ng mong mu·ªën nh∆∞ trong StyleGAN g·ªëc", "C) ƒê·ªÉ tƒÉng t·ªëc ƒë·ªô x·ª≠ l√Ω c·ªßa mapping network", "D) ƒê·ªÉ lo·∫°i b·ªè ho√†n to√†n nhu c·∫ßu v·ªÅ nhi·ªÖu ng·∫´u nhi√™n (noise inputs)"],
        correct: 1,
        explanation: "StyleGAN g·ªëc s·ª≠ d·ª•ng Adaptive Instance Normalization (AdaIN) ƒë·ªÉ ƒë∆∞a th√¥ng tin style v√†o. Tuy nhi√™n, AdaIN c√≥ th·ªÉ g√¢y ra c√°c artifact d·∫°ng gi·ªçt n∆∞·ªõc. StyleGAN2 thay th·∫ø AdaIN b·∫±ng modulated convolution v√† demodulation. Modulated convolution scale c√°c tr·ªçng s·ªë c·ªßa l·ªõp t√≠ch ch·∫≠p d·ª±a tr√™n vector style. Demodulation sau ƒë√≥ chu·∫©n h√≥a l·∫°i output ƒë·ªÉ ƒë·∫£m b·∫£o c√°c ƒë·∫∑c tr∆∞ng kh√¥ng b·ªã thay ƒë·ªïi v·ªÅ ƒë·ªô l·ªõn m·ªôt c√°ch kh√¥ng ki·ªÉm so√°t. ƒêi·ªÅu n√†y gi√∫p ki·ªÉm so√°t style t·ªët h∆°n v√† gi·∫£m artifact.",
        difficulty: "Expert"
    },
    {
        question: "Consistency Regularization l√† m·ªôt k·ªπ thu·∫≠t quan tr·ªçng trong h·ªçc b√°n gi√°m s√°t (Semi-Supervised Learning) cho GAN. √ù t∆∞·ªüng ch√≠nh c·ªßa n√≥ l√† g√¨?",
        options: ["A) Bu·ªôc Generator ph·∫£i t·∫°o ra c√°c m·∫´u gi·ªëng h·ªát nhau n·∫øu ƒë·∫ßu v√†o nhi·ªÖu gi·ªëng nhau", "B) Bu·ªôc Discriminator ph·∫£i ƒë∆∞a ra d·ª± ƒëo√°n nh·∫•t qu√°n (v√≠ d·ª•: c√πng m·ªôt l·ªõp) cho m·ªôt m·∫´u kh√¥ng nh√£n khi m·∫´u ƒë√≥ b·ªã nhi·ªÖu lo·∫°n nh·∫π b·ªüi c√°c ph√©p tƒÉng c∆∞·ªùng d·ªØ li·ªáu kh√°c nhau", "C) ƒê·∫£m b·∫£o r·∫±ng h√†m m·∫•t m√°t c·ªßa Generator v√† Discriminator lu√¥n gi·∫£m ƒë·ªÅu", "D) Gi·ªØ cho c√°c tr·ªçng s·ªë c·ªßa Generator v√† Discriminator kh√¥ng thay ƒë·ªïi qu√° nhi·ªÅu gi·ªØa c√°c epoch"],
        correct: 1,
        explanation: "Trong h·ªçc b√°n gi√°m s√°t, ch√∫ng ta c√≥ nhi·ªÅu d·ªØ li·ªáu kh√¥ng nh√£n. Consistency Regularization khuy·∫øn kh√≠ch Discriminator ƒë∆∞a ra c√°c d·ª± ƒëo√°n gi·ªëng nhau cho c√πng m·ªôt m·∫´u kh√¥ng nh√£n khi m·∫´u ƒë√≥ ƒë∆∞·ª£c ƒë∆∞a qua c√°c ph√©p data augmentation kh√°c nhau. V√≠ d·ª•, n·∫øu m·ªôt ·∫£nh kh√¥ng nh√£n ƒë∆∞·ª£c xoay nh·∫π, Discriminator v·∫´n n√™n d·ª± ƒëo√°n n√≥ thu·ªôc c√πng m·ªôt l·ªõp (n·∫øu n√≥ l√† m·∫´u th·∫≠t) ho·∫∑c v·∫´n l√† m·∫´u gi·∫£. ƒêi·ªÅu n√†y gi√∫p Discriminator h·ªçc c√°c bi·ªÉu di·ªÖn m·∫°nh m·∫Ω h∆°n t·ª´ d·ªØ li·ªáu kh√¥ng nh√£n.",
        difficulty: "Expert"
    },
    {
        question: "Trong c√°c phi√™n b·∫£n YOLO g·∫ßn ƒë√¢y (v√≠ d·ª• DAMO-YOLO, RTMDet), kh√°i ni·ªám 'label assignment' ƒë·ªông (dynamic label assignment) nh∆∞ SimOTA, TAL c√≥ ∆∞u ƒëi·ªÉm g√¨ so v·ªõi c√°c ph∆∞∆°ng ph√°p g√°n nh√£n tƒ©nh d·ª±a tr√™n IoU c·ªë ƒë·ªãnh?",
        options: ["A) Lu√¥n g√°n nhi·ªÅu anchor box h∆°n cho m·ªói ƒë·ªëi t∆∞·ª£ng ground truth", "B) Gi·∫£m ƒë√°ng k·ªÉ s·ªë l∆∞·ª£ng ƒë·ªëi t∆∞·ª£ng ground truth c·∫ßn thi·∫øt ƒë·ªÉ hu·∫•n luy·ªán", "C) Cho ph√©p m√¥ h√¨nh t·ª± ƒë·ªông quy·∫øt ƒë·ªãnh c√°c anchor box/√¥ l∆∞·ªõi 't·ªët nh·∫•t' ƒë·ªÉ ch·ªãu tr√°ch nhi·ªám cho m·ªói ƒë·ªëi t∆∞·ª£ng d·ª±a tr√™n chi ph√≠ k·∫øt h·ª£p (v√≠ d·ª•: loss ph√¢n lo·∫°i v√† loss h·ªìi quy), thay v√¨ ch·ªâ d·ª±a tr√™n IoU v·ªõi anchor c·ªë ƒë·ªãnh. ƒêi·ªÅu n√†y gi√∫p gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ m·∫•t c√¢n b·∫±ng gi·ªØa c√°c anchor d∆∞∆°ng/√¢m t·ªët h∆°n.", "D) Lo·∫°i b·ªè ho√†n to√†n nhu c·∫ßu v·ªÅ anchor box"],
        correct: 2,
        explanation: "C√°c ph∆∞∆°ng ph√°p g√°n nh√£n tƒ©nh (v√≠ d·ª•: g√°n anchor cho ground truth n·∫øu IoU > 0.5) c√≥ th·ªÉ kh√¥ng t·ªëi ∆∞u. G√°n nh√£n ƒë·ªông nh∆∞ SimOTA (trong YOLOX) hay Task Alignment Learning (TAL) (trong RTMDet) xem x√©t c·∫£ ch·∫•t l∆∞·ª£ng ph√¢n lo·∫°i v√† ch·∫•t l∆∞·ª£ng h·ªìi quy c·ªßa c√°c d·ª± ƒëo√°n t·ª´ c√°c anchor/√¥ l∆∞·ªõi kh√°c nhau ƒë·ªÉ quy·∫øt ƒë·ªãnh g√°n nh√£n m·ªôt c√°ch linh ho·∫°t h∆°n trong qu√° tr√¨nh hu·∫•n luy·ªán. ƒêi·ªÅu n√†y gi√∫p m√¥ h√¨nh ch·ªçn ƒë∆∞·ª£c c√°c m·∫´u 'd∆∞∆°ng' ch·∫•t l∆∞·ª£ng cao h∆°n, c·∫£i thi·ªán hi·ªáu su·∫•t.",
        difficulty: "Expert"
    },
    {
        question: "S·ª± kh√°c bi·ªát ch√≠nh trong c√°ch ti·∫øp c·∫≠n c·ªßa ViT (Vision Transformer) so v·ªõi CNN truy·ªÅn th·ªëng trong vi·ªác n·∫Øm b·∫Øt th√¥ng tin kh√¥ng gian l√† g√¨?",
        options: ["A) ViT kh√¥ng s·ª≠ d·ª•ng b·∫•t k·ª≥ th√¥ng tin kh√¥ng gian n√†o", "B) ViT s·ª≠ d·ª•ng c√°c l·ªõp t√≠ch ch·∫≠p 1x1 ƒë·ªÉ n·∫Øm b·∫Øt th√¥ng tin kh√¥ng gian to√†n c·ª•c", "C) CNN d·ª±a v√†o c√°c ph√©p t√≠ch ch·∫≠p c·ª•c b·ªô ƒë·ªÉ x√¢y d·ª±ng bi·ªÉu di·ªÖn ph√¢n c·∫•p. ViT chia ·∫£nh th√†nh c√°c patch, coi ch√∫ng nh∆∞ m·ªôt chu·ªói v√† s·ª≠ d·ª•ng self-attention ƒë·ªÉ n·∫Øm b·∫Øt m·ªëi quan h·ªá to√†n c·ª•c gi·ªØa c√°c patch ngay t·ª´ ƒë·∫ßu, k·∫øt h·ª£p v·ªõi positional embedding.", "D) ViT ch·ªâ ho·∫°t ƒë·ªông t·ªët v·ªõi ·∫£nh x√°m"],
        correct: 2,
        explanation: "CNN x√¢y d·ª±ng c√°c ƒë·∫∑c tr∆∞ng t·ª´ c·ª•c b·ªô ƒë·∫øn to√†n c·ª•c th√¥ng qua vi·ªác x·∫øp ch·ªìng c√°c l·ªõp t√≠ch ch·∫≠p v·ªõi receptive field tƒÉng d·∫ßn. Ng∆∞·ª£c l·∫°i, ViT chia ·∫£nh th√†nh c√°c patch, bi·∫øn ch√∫ng th√†nh m·ªôt chu·ªói c√°c token v√† s·ª≠ d·ª•ng c∆° ch·∫ø self-attention c·ªßa Transformer ƒë·ªÉ tr·ª±c ti·∫øp m√¥ h√¨nh h√≥a m·ªëi quan h·ªá gi·ªØa t·∫•t c·∫£ c√°c c·∫∑p patch. Th√¥ng tin v·ªã tr√≠ ƒë∆∞·ª£c cung c·∫•p b·ªüi positional embedding. ƒêi·ªÅu n√†y cho ph√©p ViT n·∫Øm b·∫Øt c√°c ph·ª• thu·ªôc xa (long-range dependencies) hi·ªáu qu·∫£ h∆°n ngay t·ª´ c√°c l·ªõp ƒë·∫ßu.",
        difficulty: "Expert"
    },
    {
        question: "Diffusion Models l√† m·ªôt l·ªõp m√¥ h√¨nh sinh m·∫°nh m·∫Ω g·∫ßn ƒë√¢y. Nguy√™n l√Ω ho·∫°t ƒë·ªông c∆° b·∫£n c·ªßa ch√∫ng l√† g√¨?",
        options: ["A) Hu·∫•n luy·ªán m·ªôt Generator v√† m·ªôt Discriminator ƒë·ªÉ ch∆°i tr√≤ ch∆°i minimax", "B) T·ª´ t·ª´ th√™m nhi·ªÖu v√†o d·ªØ li·ªáu th·∫≠t qua m·ªôt chu·ªói c√°c b∆∞·ªõc (forward process), sau ƒë√≥ hu·∫•n luy·ªán m·ªôt m·∫°ng n∆°-ron ƒë·ªÉ ƒë·∫£o ng∆∞·ª£c qu√° tr√¨nh n√†y, t·ª©c l√† t·ª´ t·ª´ lo·∫°i b·ªè nhi·ªÖu ƒë·ªÉ t·∫°o ra m·∫´u m·ªõi t·ª´ nhi·ªÖu thu·∫ßn t√∫y (reverse process)", "C) M√£ h√≥a d·ªØ li·ªáu v√†o m·ªôt kh√¥ng gian latent c√≥ ph√¢n ph·ªëi chu·∫©n, sau ƒë√≥ gi·∫£i m√£ t·ª´ kh√¥ng gian latent ƒë√≥", "D) S·ª≠ d·ª•ng m·ªôt ki·∫øn tr√∫c Transformer ƒë·ªÉ d·ª± ƒëo√°n t·ª´ng pixel c·ªßa ·∫£nh m·ªôt c√°ch t·ª± h·ªìi quy"],
        correct: 1,
        explanation: "Diffusion models ho·∫°t ƒë·ªông theo hai qu√° tr√¨nh: <br>1. <b>Forward (diffusion) process:</b> Th√™m nhi·ªÖu Gaussian m·ªôt c√°ch t·ª´ t·ª´ v√†o d·ªØ li·ªáu hu·∫•n luy·ªán qua nhi·ªÅu b∆∞·ªõc th·ªùi gian, cho ƒë·∫øn khi d·ªØ li·ªáu tr·ªü th√†nh nhi·ªÖu thu·∫ßn t√∫y. Qu√° tr√¨nh n√†y c√≥ c√¥ng th·ª©c to√°n h·ªçc x√°c ƒë·ªãnh. <br>2. <b>Reverse (denoising) process:</b> Hu·∫•n luy·ªán m·ªôt m·∫°ng n∆°-ron (th∆∞·ªùng l√† ki·∫øn tr√∫c U-Net) ƒë·ªÉ h·ªçc c√°ch ƒë·∫£o ng∆∞·ª£c qu√° tr√¨nh th√™m nhi·ªÖu. T·ª©c l√†, ·ªü m·ªói b∆∞·ªõc, m·∫°ng d·ª± ƒëo√°n nhi·ªÖu ƒë√£ ƒë∆∞·ª£c th√™m v√†o v√† lo·∫°i b·ªè n√≥. B·∫Øt ƒë·∫ßu t·ª´ nhi·ªÖu ng·∫´u nhi√™n, l·∫∑p l·∫°i qu√° tr√¨nh kh·ª≠ nhi·ªÖu n√†y s·∫Ω t·∫°o ra m·ªôt m·∫´u d·ªØ li·ªáu m·ªõi. Diffusion models n·ªïi ti·∫øng v·ªõi kh·∫£ nƒÉng sinh ·∫£nh ch·∫•t l∆∞·ª£ng r·∫•t cao.",
        difficulty: "Expert"
    }
];
        // ===================================================================================
        // == K·∫æT TH√öC PH·∫¶N D·ªÆ LI·ªÜU C√ÇU H·ªéI                                                ==
        // ===================================================================================


        const AppState = {
            currentQuestionIndex: 0,
            score: 0,
            answers: [],
            flaggedQuestions: new Set(),
            questionOrder: [],
            // timerInterval: null, // Removed
            // timeLeftPerQuestion: 30, // Removed
            // timeLeft: 30, // Removed
            isReviewMode: false,
            confettiLaunched: false
        };

        const DOM = {
            appWrapper: document.querySelector('.app-wrapper'),
            sidebar: document.getElementById('questionSidebar'),
            openSidebarBtn: document.getElementById('openSidebarBtn'),
            questionNavList: document.getElementById('questionNavList'),
            answeredCountDisplay: document.getElementById('answeredCountDisplay'),
            totalSidebarQuestionsDisplay: document.getElementById('totalSidebarQuestionsDisplay'),
            mainProgressBar: document.getElementById('mainProgressBar'),
            timerDisplay: document.getElementById('timerDisplay'),
            // timeLeftDisplay: document.getElementById('timeLeftDisplay'), // Associated with timer
            difficultyDisplay: document.getElementById('difficultyDisplayEl'),
            questionTextEl: document.getElementById('questionTextEl'),
            optionsContainerEl: document.getElementById('optionsContainerEl'),
            explanationContainerEl: document.getElementById('explanationContainerEl'),
            explanationTextEl: document.getElementById('explanationTextEl'),
            prevQuestionBtnEl: document.getElementById('prevQuestionBtnEl'),
            nextQuestionBtnEl: document.getElementById('nextQuestionBtnEl'),
            flagQuestionBtnEl: document.getElementById('flagQuestionBtnEl'),
            flagIconControlEl: document.getElementById('flagIconControlEl'),
            flagBtnTextEl: document.getElementById('flagBtnTextEl'),
            resultAreaEl: document.getElementById('resultAreaEl'),
            finalScoreDisplay: document.getElementById('finalScoreDisplay'),
            totalResultQuestionsDisplay: document.getElementById('totalResultQuestionsDisplay'),
            finalPercentageDisplay: document.getElementById('finalPercentageDisplay'),
            resultMessageEl: document.getElementById('resultMessageEl'),
            restartQuizBtnSidebar: document.getElementById('restartQuizBtnSidebar'),
            restartQuizBtnResultEl: document.getElementById('restartQuizBtnResultEl'),
            reviewAnswersBtnEl: document.getElementById('reviewAnswersBtnEl'),
            toggleDarkModeBtn: document.getElementById('toggleDarkModeBtn'),
            saveProgressBtnSidebar: document.getElementById('saveProgressBtnSidebar'),
            quizAreaEl: document.getElementById('quizAreaEl'),
            quizMainContent: document.getElementById('quizMainContent'),
            flaggedQuestionsReviewAreaEl: document.getElementById('flaggedQuestionsReviewAreaEl'),
            flaggedListEl: document.getElementById('flaggedListEl')
        };


        const QuizApp = {
            init() {
                if (questions.length === 0) {
                    DOM.questionTextEl.innerHTML = "Kh√¥ng c√≥ c√¢u h·ªèi n√†o ƒë∆∞·ª£c t·∫£i. Vui l√≤ng ki·ªÉm tra l·∫°i d·ªØ li·ªáu c√¢u h·ªèi.";
                    DOM.optionsContainerEl.innerHTML = "";
                    document.querySelector('.quiz-header').style.display = 'none';
                    DOM.quizAreaEl.style.display = 'none';
                    DOM.sidebar.style.display = 'none';
                    DOM.openSidebarBtn.style.display = 'none';
                    return;
                }
                this.setupEventListeners();
                this.loadDarkModePreference();
                this.resetStateAndStart();
                 DOM.timerDisplay.style.display = 'none'; // Hide timer display permanently
            },

            resetStateAndStart() {
                this.resetState();
                this.loadProgress();

                DOM.totalSidebarQuestionsDisplay.textContent = questions.length;
                DOM.totalResultQuestionsDisplay.textContent = questions.length;

                this.renderQuestionNav();
                this.renderCurrentQuestion();
                // if (!AppState.isReviewMode && questions.length > 0) this.startPerQuestionTimer(); // Removed timer
                this.updateUIBasedOnState();
                this.handleResize();
            },

            handleResize() {
                if (window.innerWidth <= 900) {
                    DOM.openSidebarBtn.style.display = 'block';
                } else {
                    DOM.openSidebarBtn.style.display = 'none';
                    DOM.sidebar.classList.add('open');
                }
            },
            resetState() {
                AppState.questionOrder = this.utils.shuffle([...Array(questions.length).keys()]);
                AppState.answers = new Array(questions.length).fill(null);
                AppState.currentQuestionIndex = 0;
                AppState.score = 0;
                AppState.flaggedQuestions = new Set();
                AppState.isReviewMode = false;
                AppState.confettiLaunched = false;

                DOM.quizAreaEl.style.display = 'block';
                DOM.resultAreaEl.style.display = 'none';
                DOM.flaggedQuestionsReviewAreaEl.style.display = 'none';
                DOM.reviewAnswersBtnEl.style.display = 'none';

                // TH√äM D√íNG N√ÄY ƒê·ªÇ X√ìA TI·∫æN ƒê·ªò ƒê√É L∆ØU
                try {
                    localStorage.removeItem('deepLearningQuizProgress');
                    console.log("Cleared saved progress from localStorage.");
                } catch (e) {
                    console.warn("Failed to clear saved progress from localStorage:", e);
                }
            },

            loadProgress() {
                try {
                    const saved = JSON.parse(localStorage.getItem('deepLearningQuizProgress'));
                    if (saved) {
                        if (saved.answers && saved.answers.length === questions.length) AppState.answers = saved.answers;
                        if (saved.score !== undefined) AppState.score = saved.score;
                        if (saved.flaggedQuestions) AppState.flaggedQuestions = new Set(saved.flaggedQuestions);

                        if (saved.questionOrder && saved.questionOrder.length === questions.length) {
                            AppState.questionOrder = saved.questionOrder;
                            if (saved.currentDisplayIndex !== undefined && saved.currentDisplayIndex < AppState.questionOrder.length) {
                                AppState.currentQuestionIndex = saved.currentDisplayIndex;
                            }
                        } else {
                             console.warn("Saved question order invalid or missing. Using new shuffle.");
                        }
                        console.log("Progress loaded.");
                    }
                } catch (e) { console.warn("Failed to load progress:", e); }
            },

            saveProgress() {
                try {
                    const progress = {
                        answers: AppState.answers,
                        score: AppState.score,
                        flaggedQuestions: [...AppState.flaggedQuestions],
                        currentDisplayIndex: AppState.currentQuestionIndex,
                        questionOrder: AppState.questionOrder
                    };
                    localStorage.setItem('deepLearningQuizProgress', JSON.stringify(progress));
                    this.ui.showToast("ƒê√£ l∆∞u ti·∫øn ƒë·ªô!");
                } catch (e) { console.warn("Failed to save progress:", e); }
            },

            ui: {
                showToast(message) {
                    let toast = document.getElementById('toast-notification');
                    if (!toast) {
                        toast = document.createElement('div');
                        toast.id = 'toast-notification';
                        document.body.appendChild(toast);
                    }
                    toast.textContent = message;
                    toast.classList.add('show');
                    setTimeout(() => {
                        toast.classList.remove('show');
                    }, 3000);
                }
            },

            renderCurrentQuestion() {
                if (AppState.currentQuestionIndex >= AppState.questionOrder.length || questions.length === 0) {
                    if (!AppState.isReviewMode && questions.length > 0) this.showResults();
                    return;
                }

                const originalQIndex = AppState.questionOrder[AppState.currentQuestionIndex];
                const question = questions[originalQIndex];

                DOM.questionTextEl.innerHTML = `${AppState.currentQuestionIndex + 1}. ${question.question}`;
                DOM.difficultyDisplay.textContent = `ƒê·ªô kh√≥: ${question.difficulty}`;

                DOM.optionsContainerEl.innerHTML = '';
                const userAnswer = AppState.answers[originalQIndex];

                question.options.forEach((optionText, optionIndex) => {
                    const optionEl = document.createElement('button');
                    optionEl.classList.add('option');
                    optionEl.innerHTML = optionText;
                    optionEl.dataset.index = optionIndex;

                    if (AppState.isReviewMode || userAnswer !== null) {
                        optionEl.classList.add('disabled');
                        if (optionIndex === userAnswer) {
                            optionEl.classList.add(userAnswer === question.correct ? 'correct' : 'incorrect');
                        } else if (optionIndex === question.correct) {
                            optionEl.classList.add('correct');
                        }
                    }
                    if (!AppState.isReviewMode && userAnswer === null) {
                         optionEl.addEventListener('click', () => this.handleOptionClick(optionIndex));
                    }
                    DOM.optionsContainerEl.appendChild(optionEl);
                });

                if (AppState.isReviewMode || userAnswer !== null) {
                    DOM.explanationContainerEl.style.display = 'block';
                    DOM.explanationTextEl.innerHTML = question.explanation;
                } else {
                    DOM.explanationContainerEl.style.display = 'none';
                }
                this.updateFlagButtonUI();
                this.updateUIBasedOnState();
                this.renderQuestionNav();
            },

            handleOptionClick(selectedIndex) {
                if (AppState.isReviewMode) return;

                const originalQIndex = AppState.questionOrder[AppState.currentQuestionIndex];
                if (AppState.answers[originalQIndex] !== null) return;

                // clearInterval(AppState.timerInterval); // Removed timer
                AppState.answers[originalQIndex] = selectedIndex;

                if (selectedIndex === questions[originalQIndex].correct) {
                    AppState.score++;
                    if (typeof confetti === 'function') {
                        confetti({ particleCount: 30, spread: 50, origin: { y: 0.7 }, Ticks: 100, angle: this.utils.randomInRange(45, 135) });
                    }
                }
                this.saveProgress();
                this.renderCurrentQuestion();
            },

            renderQuestionNav() {
                DOM.questionNavList.innerHTML = '';
                if (questions.length === 0) return;

                AppState.questionOrder.forEach((originalQIndex, displayIndex) => {
                    const navItem = document.createElement('div');
                    navItem.classList.add('question-nav-item');
                    const questionData = questions[originalQIndex];
                    const userAnswer = AppState.answers[originalQIndex];

                    if (displayIndex === AppState.currentQuestionIndex) {
                        navItem.classList.add('current');
                    }

                    if (userAnswer !== null) {
                        // navItem.classList.add('answered'); // Base class, might be redundant now
                        if (userAnswer === questionData.correct) {
                            navItem.classList.add('answered-correct');
                        } else {
                            navItem.classList.add('answered-incorrect');
                        }
                    }


                    const numSpan = document.createElement('span');
                    numSpan.classList.add('nav-item-number');
                    numSpan.textContent = displayIndex + 1;
                    navItem.appendChild(numSpan);

                    const flagSpan = document.createElement('span');
                    flagSpan.classList.add('nav-item-flag');
                    if (AppState.flaggedQuestions.has(originalQIndex)) {
                        flagSpan.classList.add('flagged');
                        flagSpan.textContent = 'üö©';
                    }
                    navItem.appendChild(flagSpan);

                    navItem.addEventListener('click', () => {
                        // const currentOriginalQIndex = AppState.questionOrder[AppState.currentQuestionIndex]; // Not needed as timer is removed
                        // if (AppState.answers[currentOriginalQIndex] === null && AppState.timeLeft > 0 && !AppState.isReviewMode) {} // Removed

                        AppState.currentQuestionIndex = displayIndex;
                        this.renderCurrentQuestion();
                        // if (!AppState.isReviewMode) this.startPerQuestionTimer(); // Removed
                        // else this.stopPerQuestionTimer(); // Removed

                        if (window.innerWidth <= 900 && DOM.sidebar.classList.contains('open')) {
                           DOM.sidebar.classList.remove('open');
                        }
                    });
                    DOM.questionNavList.appendChild(navItem);
                });
                DOM.answeredCountDisplay.textContent = AppState.answers.filter(a => a !== null).length;
            },

            // startPerQuestionTimer, stopPerQuestionTimer, handleTimeOut removed

            navigate(direction) {
                const currentOriginalQIndex = AppState.questionOrder[AppState.currentQuestionIndex];
                const canProceed = AppState.answers[currentOriginalQIndex] !== null || AppState.isReviewMode;

                if (direction === 'next') {
                    if (!canProceed && AppState.currentQuestionIndex < questions.length -1 && !AppState.isReviewMode) { // Added !AppState.isReviewMode
                        this.ui.showToast("Vui l√≤ng ch·ªçn ƒë√°p √°n.");
                        return;
                    }
                    if (AppState.currentQuestionIndex < questions.length - 1) {
                        AppState.currentQuestionIndex++;
                    } else if (!AppState.isReviewMode) {
                        this.showResults();
                        return;
                    } else {
                        this.ui.showToast("B·∫°n ƒëang ·ªü c√¢u cu·ªëi c√πng c·ªßa b√†i xem l·∫°i.");
                        DOM.quizAreaEl.style.display = 'none';
                        DOM.resultAreaEl.style.display = 'block';
                        this.displayFlaggedQuestionsForReview();
                        AppState.isReviewMode = false;
                        return;
                    }
                } else if (direction === 'prev') {
                    if (AppState.currentQuestionIndex > 0) {
                        AppState.currentQuestionIndex--;
                    } else if (AppState.isReviewMode) {
                        this.ui.showToast("B·∫°n ƒëang ·ªü c√¢u ƒë·∫ßu ti√™n c·ªßa b√†i xem l·∫°i.");
                        return;
                    }
                }
                this.renderCurrentQuestion();
                // No timer calls here
            },

            toggleFlagCurrentQuestion() {
                if (AppState.isReviewMode || questions.length === 0) return;
                const originalQIndex = AppState.questionOrder[AppState.currentQuestionIndex];
                if (AppState.flaggedQuestions.has(originalQIndex)) {
                    AppState.flaggedQuestions.delete(originalQIndex);
                } else {
                    AppState.flaggedQuestions.add(originalQIndex);
                }
                this.saveProgress();
                this.updateFlagButtonUI();
                this.renderQuestionNav();
            },

            updateFlagButtonUI() {
                 if (questions.length === 0) {
                    DOM.flagQuestionBtnEl.style.display = 'none';
                    return;
                }
                DOM.flagQuestionBtnEl.style.display = 'flex';
                const originalQIndex = AppState.questionOrder[AppState.currentQuestionIndex];
                if (AppState.flaggedQuestions.has(originalQIndex)) {
                    DOM.flagIconControlEl.textContent = 'üö©';
                    DOM.flagIconControlEl.classList.add('flagged');
                    DOM.flagBtnTextEl.textContent = "B·ªè ƒë√°nh d·∫•u";
                } else {
                    DOM.flagIconControlEl.textContent = 'üè≥Ô∏è';
                    DOM.flagIconControlEl.classList.remove('flagged');
                    DOM.flagBtnTextEl.textContent = "ƒê√°nh d·∫•u";
                }
            },

            updateUIBasedOnState() {
                 if (questions.length === 0) return;
                const answeredCount = AppState.answers.filter(a => a !== null).length;
                DOM.mainProgressBar.style.width = `${(answeredCount / questions.length) * 100}%`;
                DOM.answeredCountDisplay.textContent = answeredCount;

                DOM.prevQuestionBtnEl.disabled = AppState.currentQuestionIndex === 0;

                const originalQIndex = AppState.questionOrder[AppState.currentQuestionIndex];
                const isCurrentAnswered = AppState.answers[originalQIndex] !== null;

                if (AppState.isReviewMode) {
                    DOM.nextQuestionBtnEl.textContent = (AppState.currentQuestionIndex === questions.length - 1) ? "K·∫øt th√∫c xem" : "Ti·∫øp >";
                    DOM.flagQuestionBtnEl.style.display = 'none';
                    DOM.prevQuestionBtnEl.disabled = AppState.currentQuestionIndex === 0;
                    DOM.nextQuestionBtnEl.disabled = false;
                    // this.stopPerQuestionTimer(); // Removed
                } else {
                    DOM.flagQuestionBtnEl.style.display = 'flex';

                    if (AppState.currentQuestionIndex === questions.length - 1) {
                        DOM.nextQuestionBtnEl.textContent = "Ho√†n Th√†nh";
                        DOM.nextQuestionBtnEl.disabled = !isCurrentAnswered; // No longer depends on timed out
                    } else {
                        DOM.nextQuestionBtnEl.textContent = "Ti·∫øp >";
                        DOM.nextQuestionBtnEl.disabled = !isCurrentAnswered; // No longer depends on timed out
                    }
                }
            },

            showResults() {
                // this.stopPerQuestionTimer(); // Removed
                DOM.quizAreaEl.style.display = 'none';
                DOM.resultAreaEl.style.display = 'block';
                DOM.reviewAnswersBtnEl.style.display = 'inline-block';

                const percentage = (AppState.score / questions.length) * 100;
                DOM.finalScoreDisplay.textContent = `${AppState.score} / ${questions.length} (${percentage.toFixed(1)}%)`;

                let message = "";
                if (percentage >= 80) {
                    message = "Xu·∫•t s·∫Øc! B·∫°n ƒë√£ n·∫Øm v·ªØng ki·∫øn th·ª©c!";
                    if (!AppState.confettiLaunched && typeof confetti === 'function') {
                        confetti({ particleCount: 200, spread: 100, origin: { y: 0.6 }, Ticks: 200 });
                        AppState.confettiLaunched = true;
                    }
                } else if (percentage >= 60) {
                    message = "R·∫•t t·ªët! H√£y xem l·∫°i m·ªôt v√†i c√¢u ƒë·ªÉ ho√†n thi·ªán h∆°n.";
                } else if (percentage >= 40) {
                    message = "Kh√° ·ªïn! C·∫ßn √¥n t·∫≠p th√™m m·ªôt ch√∫t nh√©.";
                } else {
                    message = "C·∫ßn c·ªë g·∫Øng nhi·ªÅu h∆°n. ƒê·ª´ng n·∫£n l√≤ng, h√£y l√†m l·∫°i v√† h·ªçc h·ªèi!";
                }
                DOM.resultMessageEl.textContent = message;
                this.displayFlaggedQuestionsForReview();
                this.saveProgress();
            },

            displayFlaggedQuestionsForReview() {
                DOM.flaggedListEl.innerHTML = '';
                if (AppState.flaggedQuestions.size > 0) {
                    DOM.flaggedQuestionsReviewAreaEl.style.display = 'block';
                    AppState.flaggedQuestions.forEach(originalQIndex => {
                        const displayIndex = AppState.questionOrder.indexOf(originalQIndex);
                        if (displayIndex !== -1) {
                            const li = document.createElement('li');
                            li.innerHTML = `<b>C√¢u ${displayIndex + 1}:</b> ${questions[originalQIndex].question.substring(0,60)}...`;
                            li.dataset.displayIndex = displayIndex;
                            li.addEventListener('click', () => {
                                this.startReviewMode(displayIndex);
                            });
                            DOM.flaggedListEl.appendChild(li);
                        }
                    });
                } else {
                    DOM.flaggedQuestionsReviewAreaEl.style.display = 'none';
                }
            },

            startReviewMode(startDisplayIndex = 0) {
                if (questions.length === 0) {
                    this.ui.showToast("Kh√¥ng c√≥ c√¢u h·ªèi ƒë·ªÉ xem l·∫°i.");
                    return;
                }
                AppState.isReviewMode = true;
                AppState.currentQuestionIndex = startDisplayIndex;
                DOM.quizAreaEl.style.display = 'block';
                DOM.resultAreaEl.style.display = 'none';
                DOM.reviewAnswersBtnEl.style.display = 'none';
                this.renderCurrentQuestion();
                this.updateUIBasedOnState();
                this.ui.showToast("Ch·∫ø ƒë·ªô xem l·∫°i: B·∫°n c√≥ th·ªÉ xem c√¢u tr·∫£ l·ªùi v√† gi·∫£i th√≠ch.");
                if (window.innerWidth <= 900 && DOM.sidebar.classList.contains('open')) {
                   DOM.sidebar.classList.remove('open');
                }
            },

            handleFeedback(type) {
                const originalQIndex = AppState.questionOrder[AppState.currentQuestionIndex];
                console.log(`Feedback for question ${originalQIndex + 1} (Display: ${AppState.currentQuestionIndex + 1}): ${type}`);
                this.ui.showToast("C·∫£m ∆°n ph·∫£n h·ªìi c·ªßa b·∫°n!");
            },

            toggleDarkMode() {
                document.body.classList.toggle('dark-mode');
                localStorage.setItem('deepLearningQuizDarkMode', document.body.classList.contains('dark-mode'));
            },
            loadDarkModePreference() {
                if (localStorage.getItem('deepLearningQuizDarkMode') === 'true') {
                    document.body.classList.add('dark-mode');
                }
            },

            setupEventListeners() {
                DOM.prevQuestionBtnEl.addEventListener('click', () => this.navigate('prev'));
                DOM.nextQuestionBtnEl.addEventListener('click', () => this.navigate('next'));
                DOM.flagQuestionBtnEl.addEventListener('click', () => this.toggleFlagCurrentQuestion());

                DOM.restartQuizBtnSidebar.addEventListener('click', () => {
                    if (confirm("L√†m l·∫°i s·∫Ω x√≥a to√†n b·ªô ti·∫øn ƒë·ªô. B·∫°n ch·∫Øc ch·∫Øn?")) this.resetStateAndStart();
                });
                DOM.restartQuizBtnResultEl.addEventListener('click', () => this.resetStateAndStart());
                DOM.reviewAnswersBtnEl.addEventListener('click', () => this.startReviewMode());

                DOM.toggleDarkModeBtn.addEventListener('click', () => this.toggleDarkMode());
                DOM.saveProgressBtnSidebar.addEventListener('click', () => this.saveProgress());

                DOM.explanationContainerEl.querySelectorAll('.feedback-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.handleFeedback(e.target.dataset.feedback));
                });

                 DOM.openSidebarBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    DOM.sidebar.classList.toggle('open');
                    document.body.classList.toggle('sidebar-open', DOM.sidebar.classList.contains('open'));
                });
                DOM.quizMainContent.addEventListener('click', () => {
                    if (window.innerWidth <= 900 && DOM.sidebar.classList.contains('open')) {
                        DOM.sidebar.classList.remove('open');
                        document.body.classList.remove('sidebar-open');
                    }
                });

                document.addEventListener('keydown', (e) => {
                    if (DOM.resultAreaEl.style.display === 'block' && e.key !== 'Escape') return;
                     if (questions.length === 0 && e.key !== 'Escape') return;

                    switch (e.key.toLowerCase()) {
                        case 'arrowleft':
                        case 'a':
                            if (!DOM.prevQuestionBtnEl.disabled) this.navigate('prev');
                            break;
                        case 'arrowright':
                        case 'd':
                             if (!DOM.nextQuestionBtnEl.disabled) this.navigate('next');
                            break;
                        case 'f':
                            if (!AppState.isReviewMode) this.toggleFlagCurrentQuestion();
                            break;
                        case '1': case '2': case '3': case '4':
                            if (!AppState.isReviewMode) {
                                const optionIdx = parseInt(e.key) - 1;
                                const currentOriginalQ = AppState.questionOrder[AppState.currentQuestionIndex];
                                if (questions[currentOriginalQ] && optionIdx < questions[currentOriginalQ].options.length) {
                                    // if(AppState.answers[currentOriginalQ] === null && AppState.timeLeft > 0) { // timeLeft removed
                                    if(AppState.answers[currentOriginalQ] === null) {
                                       this.handleOptionClick(optionIdx);
                                    }
                                }
                            }
                            break;
                        case 'escape':
                            if (DOM.sidebar.classList.contains('open')) {
                                DOM.sidebar.classList.remove('open');
                                document.body.classList.remove('sidebar-open');
                            }
                            break;
                    }
                });
            },

            utils: {
                shuffle: (array) => {
                    let currentIndex = array.length, randomIndex;
                    while (currentIndex != 0) {
                        randomIndex = Math.floor(Math.random() * currentIndex);
                        currentIndex--;
                        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
                    }
                    return array;
                },
                randomInRange: (min, max) => Math.random() * (max - min) + min
            }
        };

        QuizApp.init();
    </script>
</body>
</html>